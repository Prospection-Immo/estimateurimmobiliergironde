import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import { 
  type User, 
  type Lead, 
  type Estimation, 
  type Contact,
  type Article,
  type EmailTemplate,
  type EmailHistory,
  type AuthSession,
  type Guide,
  type GuideDownload,
  type GuideAnalytics,
  type GuideEmailSequence,
  type PersonaConfigData,
  type LeadScoring,
  type ScoringConfig,
  type LeadScoreHistory,
  type SmsCampaign,
  type SmsTemplate,
  type SmsContact,
  type SmsSentMessage,
  type SmsSequence,
  type SmsSequenceEnrollment,
  type InsertUser, 
  type InsertLead, 
  type InsertEstimation, 
  type InsertContact,
  type InsertArticle,
  type InsertEmailTemplate,
  type InsertEmailHistory,
  type InsertAuthSession,
  type InsertGuide,
  type InsertGuideDownload,
  type InsertGuideAnalytics,
  type InsertGuideEmailSequence,
  type InsertPersonaConfig,
  type InsertLeadScoring,
  type InsertScoringConfig,
  type InsertLeadScoreHistory,
  type InsertSmsCampaign,
  type InsertSmsTemplate,
  type InsertSmsContact,
  type InsertSmsSentMessage,
  type InsertSmsSequence,
  type InsertSmsSequenceEnrollment,
  users,
  leads,
  estimations,
  contacts,
  articles,
  emailTemplates,
  emailHistory,
  authSessions,
  guides,
  guideDownloads,
  guideAnalytics,
  guideEmailSequences,
  personaConfigs,
  leadScoring,
  scoringConfig,
  leadScoreHistory,
  smsCampaigns,
  smsTemplates,
  smsContacts,
  smsSentMessages,
  smsSequences,
  smsSequenceEnrollments
} from "@shared/schema";
import { eq, desc, sql, and } from "drizzle-orm";

// Database connection with fallback for development
const connectionString = process.env.DATABASE_URL;

// Check if we're in a development environment
// Use explicit NODE_ENV check for better reliability
const isDevelopmentMode = process.env.NODE_ENV === 'development' && (!connectionString || connectionString.includes('3pVwZ'));

let client: any;
let db: any;

if (isDevelopmentMode) {
  console.log('ðŸ”§ Running in development mode without database connection');
  // Create a mock database client for development
  client = {
    query: () => Promise.resolve({ rows: [] }),
    end: () => Promise.resolve()
  };
  // Create mock db for development
  db = {
    select: () => ({ from: () => ({ execute: () => Promise.resolve([]) }) }),
    insert: () => ({ values: () => ({ returning: () => ({ execute: () => Promise.resolve([{ id: 'dev-1' }]) }) }) }),
    update: () => ({ set: () => ({ where: () => ({ execute: () => Promise.resolve() }) }) }),
    delete: () => ({ where: () => ({ execute: () => Promise.resolve() }) })
  };
} else {
  // Use Supabase pooled connection for better stability (port 6543 instead of 5432)
  let optimizedConnectionString = connectionString;
  if (connectionString.includes(':5432/')) {
    optimizedConnectionString = connectionString.replace(':5432/', ':6543/');
    console.log('Using Supabase pooled connection for better stability');
  }
  
  // Configure postgres client with proper options for Supabase
  client = postgres(optimizedConnectionString, {
    max: 10,                    // Pool size
    idle_timeout: 20,          // Close idle connections after 20s
    connect_timeout: 90,       // Increased timeout for better reliability
    prepare: false,            // Disable prepared statements for PgBouncer compatibility
    ssl: 'require',            // Enforce SSL for security
    transform: {
      undefined: null
    }
  });
  db = drizzle(client);
}

// Export db for direct access
export { db };

export interface IStorage {
  // Users
  getUser(id: string): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  
  // Leads
  createLead(lead: InsertLead): Promise<Lead>;
  getLeads(limit?: number): Promise<Lead[]>;
  updateLeadStatus(id: string, status: string): Promise<void>;
  
  // Estimations
  createEstimation(estimation: InsertEstimation): Promise<Estimation>;
  getEstimationsByLeadId(leadId: string): Promise<Estimation[]>;
  
  // Contacts
  createContact(contact: InsertContact): Promise<Contact>;
  getContacts(limit?: number): Promise<Contact[]>;
  
  // Articles
  createArticle(article: InsertArticle): Promise<Article>;
  getArticles(limit?: number): Promise<Article[]>;
  getAllArticles(limit?: number, status?: string, category?: string, searchQuery?: string): Promise<Article[]>;
  getArticleBySlug(slug: string): Promise<Article | undefined>;
  getArticlesByCategory(category: string, limit?: number): Promise<Article[]>;
  updateArticle(id: string, updates: Partial<InsertArticle>): Promise<Article>;
  deleteArticle(id: string): Promise<void>;
  
  // Email Templates
  createEmailTemplate(template: InsertEmailTemplate): Promise<EmailTemplate>;
  getEmailTemplates(category?: string): Promise<EmailTemplate[]>;
  getEmailTemplateById(id: string): Promise<EmailTemplate | undefined>;
  getEmailTemplateByCategory(category: string): Promise<EmailTemplate | undefined>;
  updateEmailTemplate(id: string, updates: Partial<InsertEmailTemplate>): Promise<EmailTemplate>;
  deleteEmailTemplate(id: string): Promise<void>;
  
  // Email History
  createEmailHistory(history: InsertEmailHistory): Promise<EmailHistory>;
  getEmailHistory(limit?: number, status?: string): Promise<EmailHistory[]>;
  updateEmailHistoryStatus(id: string, status: string, errorMessage?: string): Promise<void>;
  
  // Auth Sessions (2FA)
  createAuthSession(session: InsertAuthSession): Promise<AuthSession>;
  getAuthSession(id: string): Promise<AuthSession | undefined>;
  updateAuthSession(id: string, updates: Partial<InsertAuthSession>): Promise<void>;
  
  // Guides
  createGuide(guide: InsertGuide): Promise<Guide>;
  getGuides(persona?: string): Promise<Guide[]>;
  getGuideById(id: string): Promise<Guide | undefined>;
  getGuideBySlug(slug: string): Promise<Guide | undefined>;
  updateGuide(id: string, updates: Partial<InsertGuide>): Promise<Guide>;
  deleteGuide(id: string): Promise<void>;
  
  // Guide Downloads & Analytics
  createGuideDownload(download: InsertGuideDownload): Promise<GuideDownload>;
  getGuideDownloads(guideId?: string): Promise<GuideDownload[]>;
  createGuideAnalytics(analytics: InsertGuideAnalytics): Promise<GuideAnalytics>;
  getGuideAnalytics(guideId: string): Promise<GuideAnalytics[]>;
  
  // Guide Email Sequences
  createGuideEmailSequence(sequence: InsertGuideEmailSequence): Promise<GuideEmailSequence>;
  getGuideEmailSequences(leadEmail?: string): Promise<GuideEmailSequence[]>;
  updateGuideEmailSequence(id: string, updates: Partial<InsertGuideEmailSequence>): Promise<void>;
  
  // Persona Configurations
  getPersonaConfigs(): Promise<PersonaConfigData[]>;
  getPersonaConfigByPersona(persona: string): Promise<PersonaConfigData | undefined>;
  createPersonaConfig(config: InsertPersonaConfig): Promise<PersonaConfigData>;
  updatePersonaConfig(persona: string, updates: Partial<InsertPersonaConfig>): Promise<PersonaConfigData>;
  
  // Lead Scoring
  createLeadScoring(scoring: InsertLeadScoring): Promise<LeadScoring>;
  getLeadScoring(leadId: string): Promise<LeadScoring | undefined>;
  getLeadScoringByIds(leadIds: string[]): Promise<LeadScoring[]>;
  updateLeadScoring(leadId: string, updates: Partial<InsertLeadScoring>): Promise<LeadScoring>;
  getAllLeadScoring(limit?: number, qualificationStatus?: string): Promise<LeadScoring[]>;
  
  // Scoring Configuration
  createScoringConfig(config: InsertScoringConfig): Promise<ScoringConfig>;
  getScoringConfigs(): Promise<ScoringConfig[]>;
  getScoringConfigByCriteria(criteriaType: string): Promise<ScoringConfig | undefined>;
  updateScoringConfig(id: string, updates: Partial<InsertScoringConfig>): Promise<ScoringConfig>;
  deleteScoringConfig(id: string): Promise<void>;
  
  // Lead Score History
  createLeadScoreHistory(history: InsertLeadScoreHistory): Promise<LeadScoreHistory>;
  getLeadScoreHistory(leadId: string): Promise<LeadScoreHistory[]>;
  getAllScoreHistory(limit?: number): Promise<LeadScoreHistory[]>;
  
  // Lead Scoring Analytics
  getLeadScoringStats(startDate?: Date, endDate?: Date): Promise<{
    totalLeads: number;
    averageScore: number;
    qualifiedLeads: number;
    qualificationRate: number;
    hotLeads: number;
    conversionRate: number;
  }>;
  getScoreDistribution(): Promise<Array<{
    range: string;
    count: number;
    percentage: number;
  }>>;
  getBantBreakdown(): Promise<{
    budget: { average: number; distribution: Record<string, number> };
    authority: { average: number; distribution: Record<string, number> };
    need: { average: number; distribution: Record<string, number> };
    timeline: { average: number; distribution: Record<string, number> };
  }>;

  // SMS Campaigns
  createSmsCampaign(campaign: InsertSmsCampaign): Promise<SmsCampaign>;
  getSmsCampaigns(status?: string, limit?: number): Promise<SmsCampaign[]>;
  getSmsCampaignById(id: string): Promise<SmsCampaign | undefined>;
  updateSmsCampaign(id: string, updates: Partial<InsertSmsCampaign>): Promise<SmsCampaign>;
  deleteSmsCampaign(id: string): Promise<void>;
  updateSmsCampaignStats(id: string, stats: {
    sentCount?: number;
    deliveredCount?: number;
    failedCount?: number;
    clickedCount?: number;
    unsubscribedCount?: number;
    conversionCount?: number;
    actualCost?: string;
    roi?: string;
  }): Promise<void>;

  // SMS Templates
  createSmsTemplate(template: InsertSmsTemplate): Promise<SmsTemplate>;
  getSmsTemplates(category?: string, persona?: string, isActive?: boolean): Promise<SmsTemplate[]>;
  getSmsTemplateById(id: string): Promise<SmsTemplate | undefined>;
  updateSmsTemplate(id: string, updates: Partial<InsertSmsTemplate>): Promise<SmsTemplate>;
  deleteSmsTemplate(id: string): Promise<void>;
  incrementSmsTemplateUsage(id: string): Promise<void>;

  // SMS Contacts
  createSmsContact(contact: InsertSmsContact): Promise<SmsContact>;
  getSmsContacts(persona?: string, isOptedIn?: boolean, limit?: number): Promise<SmsContact[]>;
  getSmsContactById(id: string): Promise<SmsContact | undefined>;
  getSmsContactByPhone(phoneNumber: string): Promise<SmsContact | undefined>;
  updateSmsContact(id: string, updates: Partial<InsertSmsContact>): Promise<SmsContact>;
  deleteSmsContact(id: string): Promise<void>;
  optOutSmsContact(phoneNumber: string, reason?: string): Promise<void>;
  updateSmsContactStats(id: string, stats: {
    totalMessagesSent?: number;
    totalMessagesDelivered?: number;
    totalMessagesClicked?: number;
    conversionCount?: number;
    lastContactDate?: Date;
  }): Promise<void>;

  // SMS Sent Messages
  createSmsSentMessage(message: InsertSmsSentMessage): Promise<SmsSentMessage>;
  getSmsSentMessages(campaignId?: string, contactId?: string, status?: string, limit?: number): Promise<SmsSentMessage[]>;
  getSmsSentMessageById(id: string): Promise<SmsSentMessage | undefined>;
  updateSmsSentMessage(id: string, updates: Partial<InsertSmsSentMessage>): Promise<SmsSentMessage>;
  updateSmsSentMessageStatus(id: string, status: string, twilioData?: any): Promise<void>;

  // SMS Sequences
  createSmsSequence(sequence: InsertSmsSequence): Promise<SmsSequence>;
  getSmsSequences(isActive?: boolean, trigger?: string): Promise<SmsSequence[]>;
  getSmsSequenceById(id: string): Promise<SmsSequence | undefined>;
  updateSmsSequence(id: string, updates: Partial<InsertSmsSequence>): Promise<SmsSequence>;
  deleteSmsSequence(id: string): Promise<void>;

  // SMS Sequence Enrollments
  createSmsSequenceEnrollment(enrollment: InsertSmsSequenceEnrollment): Promise<SmsSequenceEnrollment>;
  getSmsSequenceEnrollments(sequenceId?: string, contactId?: string, status?: string): Promise<SmsSequenceEnrollment[]>;
  updateSmsSequenceEnrollment(id: string, updates: Partial<InsertSmsSequenceEnrollment>): Promise<SmsSequenceEnrollment>;
  getActiveSequenceEnrollments(): Promise<SmsSequenceEnrollment[]>;

  // SMS Analytics
  getSmsAnalyticsOverview(startDate?: Date, endDate?: Date): Promise<{
    totalCampaigns: number;
    activeCampaigns: number;
    totalMessagesSent: number;
    totalMessagesDelivered: number;
    totalMessagesClicked: number;
    totalUnsubscribes: number;
    deliveryRate: number;
    clickRate: number;
    unsubscribeRate: number;
    totalCost: number;
    averageCostPerMessage: number;
    totalConversions: number;
    conversionRate: number;
    roi: number;
  }>;
  getSmsCampaignPerformance(startDate?: Date, endDate?: Date): Promise<Array<{
    id: string;
    name: string;
    status: string;
    sent: number;
    delivered: number;
    clicked: number;
    conversions: number;
    deliveryRate: number;
    clickRate: number;
    conversionRate: number;
    cost: number;
    roi: number;
    createdAt: string;
  }>>;
  getSmsTemplatePerformance(): Promise<Array<{
    id: string;
    name: string;
    category: string;
    usageCount: number;
    conversionRate: number;
    averageClickRate: number;
    lastUsed?: string;
  }>>;
}

export class SupabaseStorage implements IStorage {
  // Memory store for development mode (when database is not connected)
  private memoryStore = {
    authSessions: new Map<string, AuthSession>(),
    leads: new Map<string, Lead>(),
    estimations: new Map<string, Estimation[]>()
  };

  // Users
  async getUser(id: string): Promise<User | undefined> {
    const result = await db.select().from(users).where(eq(users.id, id)).limit(1);
    return result[0];
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const result = await db.select().from(users).where(eq(users.username, username)).limit(1);
    return result[0];
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const result = await db.insert(users).values(insertUser).returning();
    return result[0];
  }

  // Leads
  async createLead(insertLead: InsertLead): Promise<Lead> {
    if (isDevelopmentMode) {
      // Create and store lead in memory for development
      const lead: Lead = {
        id: `dev-lead-${Date.now()}`,
        email: insertLead.email,
        phone: insertLead.phone,
        firstName: insertLead.firstName,
        lastName: insertLead.lastName,
        propertyType: insertLead.propertyType,
        address: insertLead.address,
        city: insertLead.city,
        postalCode: insertLead.postalCode,
        surface: insertLead.surface,
        rooms: insertLead.rooms,
        bedrooms: insertLead.bedrooms,
        bathrooms: insertLead.bathrooms,
        hasGarden: insertLead.hasGarden || false,
        hasParking: insertLead.hasParking || false,
        hasBalcony: insertLead.hasBalcony || false,
        constructionYear: insertLead.constructionYear,
        estimatedValue: insertLead.estimatedValue,
        source: insertLead.source,
        status: insertLead.status || 'new',
        notes: insertLead.notes,
        createdAt: new Date()
      };
      
      // Store in memory
      this.memoryStore.leads.set(lead.id, lead);
      
      return lead;
    }
    
    const result = await db.insert(leads).values(insertLead).returning();
    return result[0];
  }

  async getLeads(limit = 50): Promise<Lead[]> {
    if (isDevelopmentMode) {
      // Read from memory in development mode
      const leadsArray = Array.from(this.memoryStore.leads.values());
      return leadsArray
        .sort((a, b) => b.createdAt!.getTime() - a.createdAt!.getTime())
        .slice(0, limit);
    }
    return await db.select().from(leads).orderBy(desc(leads.createdAt)).limit(limit);
  }

  async updateLeadStatus(id: string, status: string): Promise<void> {
    await db.update(leads).set({ status }).where(eq(leads.id, id));
  }

  // Estimations
  async createEstimation(insertEstimation: InsertEstimation): Promise<Estimation> {
    if (isDevelopmentMode) {
      // Create and store estimation in memory for development
      const estimation: Estimation = {
        id: `dev-estimation-${Date.now()}`,
        leadId: insertEstimation.leadId,
        propertyType: insertEstimation.propertyType,
        address: insertEstimation.address,
        city: insertEstimation.city,
        surface: insertEstimation.surface,
        rooms: insertEstimation.rooms,
        estimatedValue: insertEstimation.estimatedValue,
        pricePerM2: insertEstimation.pricePerM2,
        confidence: insertEstimation.confidence,
        methodology: insertEstimation.methodology,
        comparableProperties: insertEstimation.comparableProperties,
        createdAt: new Date()
      };
      
      // Store in memory
      if (!this.memoryStore.estimations.has(insertEstimation.leadId)) {
        this.memoryStore.estimations.set(insertEstimation.leadId, []);
      }
      this.memoryStore.estimations.get(insertEstimation.leadId)!.push(estimation);
      
      return estimation;
    }
    
    const result = await db.insert(estimations).values(insertEstimation).returning();
    return result[0];
  }

  async getEstimationsByLeadId(leadId: string): Promise<Estimation[]> {
    if (isDevelopmentMode) {
      // Read from memory in development mode
      return this.memoryStore.estimations.get(leadId) || [];
    }
    return await db.select().from(estimations).where(eq(estimations.leadId, leadId));
  }

  async getEstimations(): Promise<Estimation[]> {
    return await db.select().from(estimations).orderBy(desc(estimations.createdAt));
  }

  // Contacts
  async createContact(insertContact: InsertContact): Promise<Contact> {
    const result = await db.insert(contacts).values(insertContact).returning();
    return result[0];
  }

  async getContacts(limit = 50): Promise<Contact[]> {
    return await db.select().from(contacts).orderBy(desc(contacts.createdAt)).limit(limit);
  }

  // Articles
  async createArticle(insertArticle: InsertArticle): Promise<Article> {
    const result = await db.insert(articles).values(insertArticle).returning();
    return result[0];
  }

  async getArticles(limit = 50): Promise<Article[]> {
    if (isDevelopmentMode) {
      // Return mock articles for development
      const mockArticles = [
        {
          id: 'dev-article-1',
          title: 'Comment estimer sa maison en Gironde : Guide complet 2025',
          slug: 'comment-estimer-maison-gironde-guide-2025',
          content: `
            <h2>L'estimation immobiliÃ¨re en Gironde : les fondamentaux</h2>
            <p>Estimer correctement sa maison en Gironde nÃ©cessite une approche mÃ©thodique et une connaissance approfondie du marchÃ© local. La Gironde, avec ses spÃ©cificitÃ©s gÃ©ographiques allant des vignobles de Saint-Ã‰milion aux quartiers rÃ©sidentiels de Bordeaux, prÃ©sente une grande diversitÃ© de prix au mÂ².</p>
            
            <h3>Les critÃ¨res essentiels d'Ã©valuation</h3>
            <p>Plusieurs facteurs influencent directement la valeur de votre bien :</p>
            <ul>
              <li><strong>L'emplacement</strong> : proximitÃ© de Bordeaux, accessibilitÃ© transports</li>
              <li><strong>La superficie et configuration</strong> : surface habitable, nombre de piÃ¨ces</li>
              <li><strong>L'Ã©tat gÃ©nÃ©ral</strong> : travaux rÃ©cents, isolation, chauffage</li>
              <li><strong>Les prestations</strong> : jardin, garage, balcon, cave</li>
            </ul>
            
            <h3>Prix moyens en Gironde fin 2024</h3>
            <p>Le marchÃ© girondin affiche des prix contrastÃ©s selon les secteurs :</p>
            <ul>
              <li>Bordeaux centre : 4 500-6 000 â‚¬/mÂ²</li>
              <li>PÃ©riphÃ©rie bordelaise : 3 200-4 200 â‚¬/mÂ²</li>
              <li>Communes rurales : 1 800-2 800 â‚¬/mÂ²</li>
              <li>Littoral bassin d'Arcachon : 5 000-8 000 â‚¬/mÂ²</li>
            </ul>
            
            <h3>MÃ©thode d'estimation par comparaison</h3>
            <p>La mÃ©thode la plus fiable consiste Ã  analyser les ventes rÃ©centes de biens similaires dans votre secteur. Consultez les bases de donnÃ©es notariales et les annonces pour Ã©tablir une fourchette de prix rÃ©aliste.</p>
            
            <h3>Quand faire appel Ã  un professionnel ?</h3>
            <p>Un expert immobilier local apporte une valeur ajoutÃ©e prÃ©cieuse, notamment pour les biens atypiques ou dans les secteurs en mutation. Son analyse fine du quartier et sa connaissance des acheteurs potentiels garantissent une estimation juste.</p>
            
            <p><em>Une estimation prÃ©cise est la clÃ© d'une vente rÃ©ussie dans les dÃ©lais souhaitÃ©s.</em></p>
          `,
          summary: 'DÃ©couvrez comment estimer correctement votre maison en Gironde avec notre guide expert. MÃ©thodes, prix moyens 2025 et conseils pratiques.',
          metaDescription: 'Guide complet pour estimer sa maison en Gironde en 2025. Prix moyens, critÃ¨res d\'Ã©valuation et conseils d\'experts immobiliers.',
          keywords: ['estimation immobiliÃ¨re gironde', 'prix immobilier bordeaux', 'vendre maison gironde', 'estimation gratuite'],
          category: 'estimation',
          status: 'published' as const,
          authorName: 'Sophie Martinez - Expert Immobilier',
          publishedAt: new Date('2025-01-10'),
          createdAt: new Date('2025-01-10'),
          updatedAt: null
        },
        {
          id: 'dev-article-2', 
          title: 'MarchÃ© immobilier Bordeaux 2025 : tendances et prÃ©visions',
          slug: 'marche-immobilier-bordeaux-2025-tendances-previsions',
          content: `
            <h2>Ã‰tat du marchÃ© immobilier bordelais dÃ©but 2025</h2>
            <p>Le marchÃ© immobilier de Bordeaux entame 2025 dans un contexte de stabilisation aprÃ¨s plusieurs annÃ©es de forte hausse. Les prix affichent une modÃ©ration bienvenue, crÃ©ant de nouvelles opportunitÃ©s pour les acquÃ©reurs.</p>
            
            <h3>Ã‰volution des prix sur 12 mois</h3>
            <p>L'analyse des transactions de 2024 rÃ©vÃ¨le :</p>
            <ul>
              <li>Stabilisation des prix dans l'ancien : +1,2% sur l'annÃ©e</li>
              <li>LÃ©ger recul du neuf : -2,5% en moyenne</li>
              <li>DÃ©lais de vente rallongÃ©s : 95 jours en moyenne</li>
              <li>NÃ©gociations plus frÃ©quentes : -3% en moyenne sur les prix annoncÃ©s</li>
            </ul>
            
            <h3>Secteurs porteurs et dÃ©laissÃ©s</h3>
            <p><strong>Quartiers en demande :</strong></p>
            <ul>
              <li>CaudÃ©ran : recherchÃ© pour ses espaces verts</li>
              <li>Saint-Augustin : proximitÃ© tram et commerces</li>
              <li>Chartrons : cachet historique prÃ©servÃ©</li>
            </ul>
            
            <p><strong>Secteurs en difficultÃ© :</strong></p>
            <ul>
              <li>Bacalan : saturation de l'offre neuve</li>
              <li>Bastide : concurrence forte</li>
            </ul>
            
            <h3>PrÃ©visions 2025</h3>
            <p>Les experts anticipent :</p>
            <ul>
              <li>Poursuite de la stabilisation des prix</li>
              <li>Retour progressif des primo-accÃ©dants</li>
              <li>IntÃ©rÃªt maintenu pour les biens rÃ©novÃ©s</li>
              <li>DÃ©veloppement du marchÃ© des rÃ©sidences secondaires</li>
            </ul>
            
            <h3>Conseils pour vendeurs et acheteurs</h3>
            <p><strong>Vendeurs :</strong> PrivilÃ©giez un prix attractif dÃ¨s le dÃ©part pour rÃ©duire les dÃ©lais de vente. La prÃ©sentation du bien devient cruciale.</p>
            <p><strong>Acheteurs :</strong> Le pouvoir de nÃ©gociation s'amÃ©liore. Prenez le temps de comparer et n'hÃ©sitez pas Ã  faire des offres rÃ©flÃ©chies.</p>
          `,
          summary: 'Analyse complÃ¨te du marchÃ© immobilier bordelais en 2025 : Ã©volution des prix, secteurs porteurs et prÃ©visions d\'experts.',
          metaDescription: 'MarchÃ© immobilier Bordeaux 2025 : prix, tendances et prÃ©visions. Analyse experte des secteurs porteurs et conseils achat-vente.',
          keywords: ['marchÃ© immobilier bordeaux', 'prix bordeaux 2025', 'achat appartement bordeaux', 'vente maison bordeaux'],
          category: 'marche',
          status: 'published' as const,
          authorName: 'Jean-Pierre Dubois - Analyste MarchÃ©',
          publishedAt: new Date('2025-01-08'),
          createdAt: new Date('2025-01-08'),
          updatedAt: null
        },
        {
          id: 'dev-article-3',
          title: '10 conseils pour vendre rapidement sa maison en Gironde',
          slug: '10-conseils-vendre-rapidement-maison-gironde',
          content: `
            <h2>Comment accÃ©lÃ©rer la vente de votre maison en Gironde</h2>
            <p>Vendre rapidement sa maison en Gironde demande une stratÃ©gie bien pensÃ©e. Voici nos 10 conseils essentiels pour optimiser votre vente et sÃ©duire les acquÃ©reurs potentiels.</p>
            
            <h3>1. Fixez le bon prix dÃ¨s le dÃ©part</h3>
            <p>Un prix juste dÃ¨s la mise sur le marchÃ© gÃ©nÃ¨re immÃ©diatement de l'intÃ©rÃªt. SurÃ©valuer votre bien retarde la vente et dÃ©valorise votre propriÃ©tÃ© aux yeux des acquÃ©reurs.</p>
            
            <h3>2. Soignez la premiÃ¨re impression</h3>
            <p>La faÃ§ade, l'entrÃ©e et le jardin sont cruciaux. Un coup de peinture, quelques plantations et un nettoyage approfondi peuvent transformer la perception de votre bien.</p>
            
            <h3>3. DÃ©personnalisez votre intÃ©rieur</h3>
            <p>Les acquÃ©reurs doivent se projeter. Rangez les objets personnels, photos de famille et dÃ©corations trop spÃ©cifiques. Optez pour une dÃ©coration neutre et moderne.</p>
            
            <h3>4. Optimisez l'Ã©clairage</h3>
            <p>Un intÃ©rieur lumineux paraÃ®t plus grand et plus accueillant. Ouvrez tous les volets, allumez les lampes lors des visites et nettoyez les fenÃªtres.</p>
            
            <h3>5. Effectuez les petites rÃ©parations</h3>
            <p>Robinetterie qui fuit, peinture Ã©caillÃ©e, poignÃ©es dÃ©faillantes : ces dÃ©tails crÃ©ent une impression de mal-entretien. Investissez dans ces rÃ©parations mineures.</p>
            
            <h3>6. Mettez en valeur vos atouts</h3>
            <p>Jardin, garage, cave, proximitÃ© Ã©coles ou transports : valorisez tous les plus de votre propriÃ©tÃ© dans vos annonces et lors des visites.</p>
            
            <h3>7. Choisissez le bon moment pour vendre</h3>
            <p>En Gironde, le printemps et l'automne sont les saisons les plus favorables. Ã‰vitez juillet-aoÃ»t et dÃ©cembre-janvier si possible.</p>
            
            <h3>8. Soyez flexible sur les visites</h3>
            <p>Plus vous proposez de crÃ©neaux, plus vous multipliez vos chances. Week-ends et fins d'aprÃ¨s-midi sont particuliÃ¨rement demandÃ©s.</p>
            
            <h3>9. PrÃ©parez vos documents</h3>
            <p>Diagnostics, factures de travaux, charges de copropriÃ©tÃ© : avoir tous les documents prÃªts rassure les acquÃ©reurs et accÃ©lÃ¨re les dÃ©marches.</p>
            
            <h3>10. Travaillez avec un professionnel local</h3>
            <p>Un agent immobilier girondin connaÃ®t parfaitement son marchÃ©, dispose d'un fichier client qualifiÃ© et sait nÃ©gocier efficacement.</p>
            
            <p><em>L'application de ces conseils peut rÃ©duire significativement votre dÃ©lai de vente, souvent de plusieurs mois.</em></p>
          `,
          summary: '10 conseils essentiels d\'experts pour vendre rapidement votre maison en Gironde. StratÃ©gies Ã©prouvÃ©es pour sÃ©duire les acquÃ©reurs.',
          metaDescription: '10 conseils d\'experts pour vendre rapidement sa maison en Gironde. Prix, prÃ©sentation, timing : tout pour rÃ©ussir votre vente immobiliÃ¨re.',
          keywords: ['vendre maison rapidement gironde', 'conseils vente immobiliÃ¨re', 'vente rapide bordeaux', 'expert immobilier gironde'],
          category: 'conseils',
          status: 'published' as const,
          authorName: 'Marie Lagrange - Consultante ImmobiliÃ¨re',
          publishedAt: new Date('2025-01-05'),
          createdAt: new Date('2025-01-05'),
          updatedAt: null
        },
        {
          id: 'dev-article-4',
          title: 'Investir dans l\'immobilier en Gironde : opportunitÃ©s 2025',
          slug: 'investir-immobilier-gironde-opportunites-2025',
          content: `
            <h2>L'investissement immobilier en Gironde : panorama 2025</h2>
            <p>La Gironde offre des opportunitÃ©s d'investissement diversifiÃ©es, de l'immobilier locatif traditionnel aux rÃ©sidences de tourisme. DÃ©couvrez les secteurs porteurs et les stratÃ©gies gagnantes pour 2025.</p>
            
            <h3>Les secteurs gÃ©ographiques d'avenir</h3>
            <p><strong>Bordeaux MÃ©tropole :</strong></p>
            <ul>
              <li>Forte demande locative Ã©tudiante et jeunes actifs</li>
              <li>Rendements bruts : 4-6% selon secteurs</li>
              <li>Plus-values Ã  long terme assurÃ©es</li>
            </ul>
            
            <p><strong>Bassin d'Arcachon :</strong></p>
            <ul>
              <li>MarchÃ© de la rÃ©sidence secondaire dynamique</li>
              <li>Location saisonniÃ¨re trÃ¨s rentable</li>
              <li>Contraintes rÃ©glementaires Ã  anticiper</li>
            </ul>
            
            <p><strong>Communes pÃ©riurbaines :</strong></p>
            <ul>
              <li>Maisons avec jardin trÃ¨s recherchÃ©es</li>
              <li>Prix d'achat encore abordables</li>
              <li>DÃ©veloppement des infrastructures</li>
            </ul>
            
            <h3>Typologie de biens Ã  privilÃ©gier</h3>
            <p><strong>Appartements T2-T3 Bordeaux :</strong></p>
            <p>IdÃ©aux pour la location aux Ã©tudiants et jeunes actifs. Secteurs Victoire, Saint-Michel et Bastide particuliÃ¨rement intÃ©ressants.</p>
            
            <p><strong>Maisons rÃ©novÃ©es pÃ©riphÃ©rie :</strong></p>
            <p>Forte demande des familles cherchant Ã  fuir les centres-villes. Potentiel de plus-value important sur 10-15 ans.</p>
            
            <p><strong>Biens atypiques centre-ville :</strong></p>
            <p>Lofts, Ã©choppes rÃ©novÃ©es : niche haut de gamme avec rendements attractifs.</p>
            
            <h3>Financement et fiscalitÃ©</h3>
            <p>Les taux d'intÃ©rÃªt stabilisÃ©s autour de 4% rendent l'investissement locatif Ã  nouveau attractif. Dispositifs fiscaux disponibles :</p>
            <ul>
              <li>Loi Pinel dans certaines zones</li>
              <li>DÃ©ficit foncier pour les rÃ©novations lourdes</li>
              <li>RÃ©gime rÃ©el pour optimiser la fiscalitÃ©</li>
            </ul>
            
            <h3>PiÃ¨ges Ã  Ã©viter</h3>
            <ul>
              <li>Surestimer les loyers potentiels</li>
              <li>NÃ©gliger les charges de copropriÃ©tÃ©</li>
              <li>Ignorer l'Ã©volution urbaine du quartier</li>
              <li>Investir sans Ã©tude de marchÃ© locative</li>
            </ul>
            
            <h3>Conseil d'expert</h3>
            <p>L'investissement immobilier girondin reste pertinent en 2025, Ã  condition de bien choisir son secteur et son type de bien. La connaissance fine du marchÃ© local est indispensable pour sÃ©curiser son investissement.</p>
          `,
          summary: 'Guide complet pour investir dans l\'immobilier girondin en 2025 : secteurs porteurs, rendements et stratÃ©gies d\'investissement.',
          metaDescription: 'Investissement immobilier Gironde 2025 : secteurs porteurs, rendements locatifs et conseils d\'experts. Guide complet pour investisseurs.',
          keywords: ['investissement immobilier gironde', 'rendement locatif bordeaux', 'achat investissement bordeaux', 'immobilier locatif gironde'],
          category: 'investissement',
          status: 'published' as const,
          authorName: 'Philippe Rousseau - Conseiller Patrimoine',
          publishedAt: new Date('2025-01-03'),
          createdAt: new Date('2025-01-03'),
          updatedAt: null
        },
        {
          id: 'dev-article-5',
          title: 'Vente immobiliÃ¨re : droits et obligations en Gironde',
          slug: 'vente-immobiliere-droits-obligations-gironde',
          content: `
            <h2>Cadre juridique de la vente immobiliÃ¨re en Gironde</h2>
            <p>Vendre un bien immobilier en Gironde implique le respect d'un cadre juridique prÃ©cis. Vendeurs et acquÃ©reurs ont des droits et obligations qu'il convient de maÃ®triser pour sÃ©curiser la transaction.</p>
            
            <h3>Obligations du vendeur</h3>
            <p><strong>Information et diagnostics :</strong></p>
            <ul>
              <li>Diagnostic de performance Ã©nergÃ©tique (DPE)</li>
              <li>Ã‰tat relatif Ã  la prÃ©sence d'amiante</li>
              <li>Constat de risque d'exposition au plomb</li>
              <li>Ã‰tat de l'installation intÃ©rieure d'Ã©lectricitÃ©</li>
              <li>Ã‰tat de l'installation intÃ©rieure de gaz</li>
              <li>Ã‰tat relatif Ã  la prÃ©sence de termites</li>
              <li>Ã‰tat des risques naturels et technologiques</li>
            </ul>
            
            <p><strong>Vice cachÃ© :</strong></p>
            <p>Le vendeur doit garantir l'acquÃ©reur contre les vices cachÃ©s qui rendraient le bien impropre Ã  sa destination ou en diminueraient l'usage.</p>
            
            <h3>SpÃ©cificitÃ©s girondines</h3>
            <p><strong>Zones Ã  risque :</strong></p>
            <p>Certaines communes girondines sont classÃ©es en zones de sismicitÃ© modÃ©rÃ©e ou en zones de retrait-gonflement des argiles, nÃ©cessitant des informations complÃ©mentaires.</p>
            
            <p><strong>Patrimoine historique :</strong></p>
            <p>Bordeaux Ã©tant classÃ© UNESCO, certains biens sont soumis Ã  l'avis des Architectes des BÃ¢timents de France pour les modifications.</p>
            
            <h3>La promesse de vente</h3>
            <p>Document engageant le vendeur pendant une durÃ©e dÃ©terminÃ©e. En Gironde, la pratique locale favorise :</p>
            <ul>
              <li>DÃ©lai de rÃ©tractation de 10 jours pour l'acquÃ©reur</li>
              <li>Conditions suspensives (financement, vente du bien actuel)</li>
              <li>Clause pÃ©nale en cas de dÃ©sistement non justifiÃ©</li>
            </ul>
            
            <h3>L'acte de vente dÃ©finitif</h3>
            <p>SignÃ© devant notaire, il doit contenir :</p>
            <ul>
              <li>L'identitÃ© complÃ¨te des parties</li>
              <li>La dÃ©signation prÃ©cise du bien</li>
              <li>Le prix et les modalitÃ©s de paiement</li>
              <li>Les garanties donnÃ©es par le vendeur</li>
              <li>L'origine de propriÃ©tÃ©</li>
            </ul>
            
            <h3>Frais et taxes</h3>
            <p><strong>Ã€ la charge de l'acquÃ©reur :</strong></p>
            <ul>
              <li>Frais de notaire : 7-8% de la valeur dans l'ancien</li>
              <li>Droits de mutation : 5,81% en Gironde</li>
              <li>Ã‰moluments et dÃ©bours du notaire</li>
            </ul>
            
            <p><strong>Ã€ la charge du vendeur :</strong></p>
            <ul>
              <li>Diagnostics immobiliers : 500-1500â‚¬</li>
              <li>Plus-value immobiliÃ¨re si applicable</li>
              <li>Frais d'agence si mandatement</li>
            </ul>
            
            <h3>Recours en cas de litige</h3>
            <p>En cas de conflit, plusieurs solutions existent :</p>
            <ul>
              <li>MÃ©diation amiable</li>
              <li>Tribunal judiciaire de Bordeaux</li>
              <li>Expertise judiciaire si vice cachÃ©</li>
            </ul>
            
            <p><em>La connaissance de vos droits et obligations sÃ©curise votre transaction immobiliÃ¨re en Gironde.</em></p>
          `,
          summary: 'Guide juridique complet de la vente immobiliÃ¨re en Gironde : obligations, diagnostics, spÃ©cificitÃ©s locales et recours.',
          metaDescription: 'Vente immobiliÃ¨re Gironde : droits, obligations et cadre juridique. Guide complet des dÃ©marches lÃ©gales pour vendeurs et acquÃ©reurs.',
          keywords: ['droit immobilier gironde', 'vente immobiliÃ¨re juridique', 'obligations vendeur bordeaux', 'diagnostics immobiliers'],
          category: 'juridique',
          status: 'published' as const,
          authorName: 'MaÃ®tre Claire Dubois - Notaire',
          publishedAt: new Date('2024-12-30'),
          createdAt: new Date('2024-12-30'),
          updatedAt: null
        },
        {
          id: 'dev-article-6',
          title: 'Prix au mÂ² en Gironde : cartographie dÃ©taillÃ©e par commune',
          slug: 'prix-m2-gironde-cartographie-commune-2025',
          content: `
            <h2>Cartographie des prix immobiliers en Gironde</h2>
            <p>La Gironde prÃ©sente une grande disparitÃ© de prix selon les communes. Notre analyse dÃ©taillÃ©e vous aide Ã  comprendre les Ã©carts et identifier les opportunitÃ©s d'achat ou de vente.</p>
            
            <h3>Bordeaux et ses arrondissements</h3>
            <p><strong>Centre historique (Triangle d'Or) :</strong></p>
            <ul>
              <li>Appartements anciens : 5 500-7 000 â‚¬/mÂ²</li>
              <li>Programmes neufs : 6 500-8 500 â‚¬/mÂ²</li>
              <li>Ã‰volution : +2,1% sur 12 mois</li>
            </ul>
            
            <p><strong>Chartrons - Grand Parc :</strong></p>
            <ul>
              <li>Appartements anciens : 4 200-5 800 â‚¬/mÂ²</li>
              <li>RÃ©novations haut de gamme : 6 000-7 200 â‚¬/mÂ²</li>
              <li>Ã‰volution : +1,8% sur 12 mois</li>
            </ul>
            
            <p><strong>Bastide - Rive Droite :</strong></p>
            <ul>
              <li>Appartements anciens : 3 800-4 600 â‚¬/mÂ²</li>
              <li>Programmes neufs : 4 500-5 500 â‚¬/mÂ²</li>
              <li>Ã‰volution : +0,5% sur 12 mois</li>
            </ul>
            
            <h3>PremiÃ¨re couronne bordelaise</h3>
            <p><strong>Communes premium :</strong></p>
            <ul>
              <li>Le Bouscat : 4 100-4 800 â‚¬/mÂ²</li>
              <li>Talence : 3 900-4 600 â‚¬/mÂ²</li>
              <li>Pessac : 3 600-4 200 â‚¬/mÂ²</li>
              <li>MÃ©rignac : 3 400-4 000 â‚¬/mÂ²</li>
            </ul>
            
            <p><strong>Secteurs en dÃ©veloppement :</strong></p>
            <ul>
              <li>BÃ¨gles : 3 200-3 800 â‚¬/mÂ²</li>
              <li>Villenave d'Ornon : 3 000-3 600 â‚¬/mÂ²</li>
              <li>Gradignan : 3 400-4 000 â‚¬/mÂ²</li>
            </ul>
            
            <h3>Bassin d'Arcachon</h3>
            <p>Le littoral girondin affiche les prix les plus Ã©levÃ©s du dÃ©partement :</p>
            <ul>
              <li>Arcachon centre : 6 000-9 000 â‚¬/mÂ²</li>
              <li>Cap Ferret : 8 000-12 000 â‚¬/mÂ²</li>
              <li>La Teste-de-Buch : 4 500-6 000 â‚¬/mÂ²</li>
              <li>Andernos-les-Bains : 4 200-5 800 â‚¬/mÂ²</li>
            </ul>
            
            <h3>Secteurs viticoles</h3>
            <p><strong>Prestige international :</strong></p>
            <ul>
              <li>Saint-Ã‰milion : 3 200-4 800 â‚¬/mÂ²</li>
              <li>Pauillac : 2 800-3 600 â‚¬/mÂ²</li>
              <li>Margaux : 3 000-4 200 â‚¬/mÂ²</li>
            </ul>
            
            <p><strong>Autres appellations :</strong></p>
            <ul>
              <li>Cadillac : 2 200-2 800 â‚¬/mÂ²</li>
              <li>Langon : 1 800-2 400 â‚¬/mÂ²</li>
              <li>CrÃ©on : 2 000-2 600 â‚¬/mÂ²</li>
            </ul>
            
            <h3>Communes rurales</h3>
            <p>L'immobilier rural girondin reste accessible :</p>
            <ul>
              <li>Haute-Gironde : 1 400-2 000 â‚¬/mÂ²</li>
              <li>Landes girondines : 1 600-2 200 â‚¬/mÂ²</li>
              <li>Entre-deux-Mers : 1 800-2 400 â‚¬/mÂ²</li>
            </ul>
            
            <h3>Facteurs d'Ã©volution 2025</h3>
            <p>Plusieurs Ã©lÃ©ments influenceront les prix :</p>
            <ul>
              <li>Extension ligne D du tramway</li>
              <li>DÃ©veloppement tÃ©lÃ©travail</li>
              <li>Nouvelle rÃ©glementation DPE</li>
              <li>ArrivÃ©e LGV Bordeaux-Toulouse</li>
            </ul>
            
            <h3>Conseil d'expertise</h3>
            <p>Ces prix sont indicatifs et peuvent varier selon l'Ã©tat du bien, ses prestations et sa situation prÃ©cise. Une estimation personnalisÃ©e reste indispensable pour toute transaction.</p>
          `,
          summary: 'Cartographie complÃ¨te des prix au mÂ² en Gironde par commune. Analyse dÃ©taillÃ©e des secteurs et tendances d\'Ã©volution 2025.',
          metaDescription: 'Prix immobilier Gironde 2025 : cartographie dÃ©taillÃ©e par commune. Bordeaux, Bassin d\'Arcachon, vignobles et secteur rural.',
          keywords: ['prix m2 gironde', 'prix immobilier bordeaux', 'marchÃ© immobilier arcachon', 'estimation prix commune gironde'],
          category: 'estimation',
          status: 'published' as const,
          authorName: 'David Moreau - Expert Foncier',
          publishedAt: new Date('2024-12-28'),
          createdAt: new Date('2024-12-28'),
          updatedAt: null
        },
        {
          id: 'dev-article-7',
          title: 'Home staging : valoriser sa maison avant la vente en Gironde',
          slug: 'home-staging-valoriser-maison-vente-gironde',
          content: `
            <h2>Le home staging : un investissement rentable en Gironde</h2>
            <p>Le home staging, art de valoriser un bien immobilier pour accÃ©lÃ©rer sa vente, connaÃ®t un succÃ¨s croissant en Gironde. Cette technique peut rÃ©duire significativement votre dÃ©lai de vente tout en optimisant le prix final.</p>
            
            <h3>Qu'est-ce que le home staging ?</h3>
            <p>Le home staging consiste Ã  prÃ©parer et mettre en scÃ¨ne votre bien pour sÃ©duire le maximum d'acquÃ©reurs potentiels. L'objectif : permettre aux visiteurs de se projeter facilement dans leur futur logement.</p>
            
            <h3>Les rÃ¨gles d'or du home staging</h3>
            <p><strong>DÃ©personnaliser :</strong></p>
            <ul>
              <li>Retirer photos personnelles et objets trop spÃ©cifiques</li>
              <li>Adopter une dÃ©coration neutre et contemporaine</li>
              <li>CrÃ©er une atmosphÃ¨re accueillante mais impersonnelle</li>
            </ul>
            
            <p><strong>DÃ©sencombrer :</strong></p>
            <ul>
              <li>Vider 50% du contenu de chaque piÃ¨ce</li>
              <li>LibÃ©rer les espaces de circulation</li>
              <li>Ranger placards et espaces de rangement</li>
            </ul>
            
            <p><strong>Nettoyer en profondeur :</strong></p>
            <ul>
              <li>Sols, murs, plafonds impeccables</li>
              <li>Vitres et miroirs Ã©tincelants</li>
              <li>Ã‰liminer toute odeur (tabac, animaux, cuisine)</li>
            </ul>
            
            <h3>SpÃ©cificitÃ©s du marchÃ© girondin</h3>
            <p><strong>Ã‰choppes bordelaises :</strong></p>
            <p>Mettez en valeur l'authenticitÃ© tout en modernisant : poutres apparentes nettoyÃ©es, parquet rÃ©novÃ©, luminaires design contrastant avec l'ancien.</p>
            
            <p><strong>Appartements haussmanniens :</strong></p>
            <p>Valorisez les volumes et la lumiÃ¨re : miroirs stratÃ©giques, couleurs claires, mobilier proportionnÃ© aux hauteurs sous plafond.</p>
            
            <p><strong>Pavillons pÃ©riurbains :</strong></p>
            <p>L'extÃ©rieur est crucial : jardin entretenu, terrasse amÃ©nagÃ©e, faÃ§ade propre. L'intÃ©rieur doit respirer la modernitÃ© et la fonctionnalitÃ©.</p>
            
            <h3>Budget et retour sur investissement</h3>
            <p><strong>CoÃ»ts moyens en Gironde :</strong></p>
            <ul>
              <li>Home staging lÃ©ger : 1 000-3 000â‚¬</li>
              <li>Home staging complet : 3 000-8 000â‚¬</li>
              <li>Location mobilier : 300-800â‚¬/mois</li>
            </ul>
            
            <p><strong>Retour sur investissement :</strong></p>
            <ul>
              <li>RÃ©duction dÃ©lai de vente : 30-50%</li>
              <li>Prix de vente prÃ©servÃ© ou bonifiÃ©</li>
              <li>Moins de nÃ©gociations sur le prix</li>
            </ul>
            
            <h3>Home staging DIY : nos conseils</h3>
            <p><strong>Ã€ faire soi-mÃªme :</strong></p>
            <ul>
              <li>Peinture fraÃ®che en blanc ou beige</li>
              <li>Remplacement des luminaires vÃ©tustes</li>
              <li>Ajout de plantes vertes</li>
              <li>RÃ©organisation du mobilier</li>
            </ul>
            
            <p><strong>Investissements judicieux :</strong></p>
            <ul>
              <li>Nouvelles poignÃ©es et robinetterie : 200-500â‚¬</li>
              <li>Coussins et rideaux modernes : 300-600â‚¬</li>
              <li>Ã‰clairage d'appoint design : 150-400â‚¬</li>
            </ul>
            
            <h3>Erreurs Ã  Ã©viter</h3>
            <ul>
              <li>Surinvestir dans des travaux lourds</li>
              <li>Imposer ses goÃ»ts personnels</li>
              <li>NÃ©gliger l'extÃ©rieur et l'entrÃ©e</li>
              <li>Oublier de crÃ©er une ambiance lors des visites</li>
            </ul>
            
            <h3>Professionnels du home staging en Gironde</h3>
            <p>De nombreux home stagers professionnels opÃ¨rent en Gironde. Ils apportent expertise, mobilier et dÃ©coration adaptÃ©s au marchÃ© local. Un investissement souvent rentabilisÃ© par une vente plus rapide et mieux valorisÃ©e.</p>
            
            <p><em>Le home staging bien exÃ©cutÃ© peut faire la diffÃ©rence sur un marchÃ© concurrentiel comme celui de la Gironde.</em></p>
          `,
          summary: 'Guide complet du home staging en Gironde pour accÃ©lÃ©rer la vente de votre maison. Techniques, budget et conseils d\'experts.',
          metaDescription: 'Home staging Gironde : valorisez votre maison avant la vente. Techniques, budget et conseils pour vendre plus vite et mieux.',
          keywords: ['home staging gironde', 'valoriser maison vente', 'vendre rapidement bordeaux', 'mise en scÃ¨ne immobiliÃ¨re'],
          category: 'conseils',
          status: 'published' as const,
          authorName: 'Isabelle Moreau - Home Stager',
          publishedAt: new Date('2024-12-25'),
          createdAt: new Date('2024-12-25'),
          updatedAt: null
        },
        {
          id: 'dev-article-8',
          title: 'RÃ©novation Ã©nergÃ©tique : impact sur la valeur immobiliÃ¨re en Gironde',
          slug: 'renovation-energetique-impact-valeur-immobiliere-gironde',
          content: `
            <h2>RÃ©novation Ã©nergÃ©tique : un levier de valorisation immobiliÃ¨re</h2>
            <p>Avec le durcissement de la rÃ©glementation DPE et la sensibilisation croissante aux enjeux environnementaux, la rÃ©novation Ã©nergÃ©tique devient un facteur dÃ©terminant de la valeur immobiliÃ¨re en Gironde.</p>
            
            <h3>Impact du DPE sur les prix</h3>
            <p>L'Ã©tiquette Ã©nergÃ©tique influence directement la valeur des biens :</p>
            <ul>
              <li><strong>Classe A-B :</strong> Bonus de 5-10% sur le prix de vente</li>
              <li><strong>Classe C-D :</strong> Valeur de rÃ©fÃ©rence du marchÃ©</li>
              <li><strong>Classe E :</strong> DÃ©cote de 5-8%</li>
              <li><strong>Classe F-G :</strong> DÃ©cote de 10-20% et difficultÃ©s de vente</li>
            </ul>
            
            <h3>Les passoires thermiques en Gironde</h3>
            <p>En Gironde, environ 17% du parc immobilier est classÃ© F ou G. Ces biens, appelÃ©s "passoires thermiques", font face Ã  :</p>
            <ul>
              <li>Des dÃ©lais de vente rallongÃ©s</li>
              <li>Des nÃ©gociations plus importantes</li>
              <li>Une interdiction de location progressive (dÃ¨s 2025 pour les G+)</li>
            </ul>
            
            <h3>Travaux prioritaires pour amÃ©liorer le DPE</h3>
            <p><strong>Isolation :</strong></p>
            <ul>
              <li>Combles : 3 000-6 000â‚¬ pour gagner 1-2 classes</li>
              <li>Murs extÃ©rieurs : 15 000-25 000â‚¬ pour gagner 2-3 classes</li>
              <li>Sol : 5 000-8 000â‚¬ pour gagner 1 classe</li>
            </ul>
            
            <p><strong>Chauffage :</strong></p>
            <ul>
              <li>Pompe Ã  chaleur : 10 000-18 000â‚¬</li>
              <li>ChaudiÃ¨re gaz condensation : 4 000-7 000â‚¬</li>
              <li>PoÃªle Ã  granulÃ©s : 3 000-6 000â‚¬</li>
            </ul>
            
            <p><strong>FenÃªtres :</strong></p>
            <ul>
              <li>Double vitrage performant : 400-800â‚¬/mÂ²</li>
              <li>Triple vitrage : 600-1 000â‚¬/mÂ²</li>
            </ul>
            
            <h3>Aides disponibles en Gironde</h3>
            <p><strong>Aides nationales :</strong></p>
            <ul>
              <li>MaPrimeRÃ©nov' : jusqu'Ã  20 000â‚¬</li>
              <li>Ã‰co-PTZ : jusqu'Ã  50 000â‚¬</li>
              <li>CEE (Certificats d'Ã‰conomie d'Ã‰nergie)</li>
              <li>TVA rÃ©duite Ã  5,5%</li>
            </ul>
            
            <p><strong>Aides locales :</strong></p>
            <ul>
              <li>Bordeaux MÃ©tropole : subventions complÃ©mentaires</li>
              <li>Conseil dÃ©partemental : aides spÃ©cifiques seniors</li>
              <li>Certaines communes : bonus rÃ©novation</li>
            </ul>
            
            <h3>Calcul de rentabilitÃ©</h3>
            <p><strong>Exemple concret - Maison 120mÂ² classe F :</strong></p>
            <ul>
              <li>Investissement rÃ©novation : 40 000â‚¬</li>
              <li>Aides obtenues : 18 000â‚¬</li>
              <li>CoÃ»t rÃ©el : 22 000â‚¬</li>
              <li>Plus-value immobiliÃ¨re : +35 000â‚¬</li>
              <li>Gain net : +13 000â‚¬ + Ã©conomies d'Ã©nergie</li>
            </ul>
            
            <h3>RÃ©novation par Ã©tapes</h3>
            <p>Une approche progressive peut Ãªtre judicieuse :</p>
            <ol>
              <li><strong>Phase 1 :</strong> Isolation des combles et changement de chauffage</li>
              <li><strong>Phase 2 :</strong> Isolation des murs par l'extÃ©rieur</li>
              <li><strong>Phase 3 :</strong> Remplacement des fenÃªtres</li>
            </ol>
            
            <h3>SpÃ©cificitÃ©s du bÃ¢ti girondin</h3>
            <p><strong>Ã‰choppes bordelaises :</strong></p>
            <p>Attention aux contraintes architecturales. L'isolation par l'intÃ©rieur est souvent privilÃ©giÃ©e pour prÃ©server les faÃ§ades.</p>
            
            <p><strong>Immeubles haussmanniens :</strong></p>
            <p>Travaux en copropriÃ©tÃ© complexes mais trÃ¨s rentables. L'isolation par l'extÃ©rieur transforme ces biens.</p>
            
            <h3>Conseil d'expert</h3>
            <p>La rÃ©novation Ã©nergÃ©tique est devenue incontournable en Gironde. Au-delÃ  de la valeur ajoutÃ©e immÃ©diate, elle prÃ©pare votre bien aux exigences futures du marchÃ© et Ã  l'Ã©volution rÃ©glementaire.</p>
            
            <p><em>Investir dans la performance Ã©nergÃ©tique, c'est investir dans l'avenir de son patrimoine immobilier.</em></p>
          `,
          summary: 'Impact de la rÃ©novation Ã©nergÃ©tique sur la valeur immobiliÃ¨re en Gironde. DPE, travaux prioritaires, aides et rentabilitÃ©.',
          metaDescription: 'RÃ©novation Ã©nergÃ©tique Gironde : impact sur la valeur immobiliÃ¨re. DPE, aides disponibles et calcul de rentabilitÃ© des travaux.',
          keywords: ['rÃ©novation Ã©nergÃ©tique gironde', 'DPE immobilier bordeaux', 'aides rÃ©novation gironde', 'passoire thermique vente'],
          category: 'conseils',
          status: 'published' as const,
          authorName: 'Thomas Leroy - Expert RÃ©novation',
          publishedAt: new Date('2024-12-22'),
          createdAt: new Date('2024-12-22'),
          updatedAt: null
        }
      ];
      
      return mockArticles.slice(0, limit);
    }
    
    return await db.select().from(articles).where(eq(articles.status, 'published')).orderBy(desc(articles.publishedAt)).limit(limit);
  }

  async getAllArticles(limit = 50, status?: string, category?: string, searchQuery?: string): Promise<Article[]> {
    // Apply filters
    const conditions = [];
    if (status && status !== 'all') {
      conditions.push(eq(articles.status, status));
    }
    if (category && category !== 'all') {
      conditions.push(eq(articles.category, category));
    }
    if (searchQuery) {
      const searchTerm = `%${searchQuery.toLowerCase()}%`;
      conditions.push(
        sql`(LOWER(${articles.title}) LIKE ${searchTerm} OR LOWER(${articles.content}) LIKE ${searchTerm} OR LOWER(${articles.summary}) LIKE ${searchTerm})`
      );
    }

    if (conditions.length > 0) {
      return await db.select().from(articles)
        .where(and(...conditions))
        .orderBy(desc(articles.createdAt))
        .limit(limit);
    }

    return await db.select().from(articles)
      .orderBy(desc(articles.createdAt))
      .limit(limit);
  }

  async getArticleBySlug(slug: string): Promise<Article | undefined> {
    const result = await db.select().from(articles).where(eq(articles.slug, slug)).limit(1);
    return result[0];
  }

  async getArticlesByCategory(category: string, limit = 20): Promise<Article[]> {
    return await db.select().from(articles)
      .where(eq(articles.category, category))
      .orderBy(desc(articles.publishedAt))
      .limit(limit);
  }

  async updateArticle(id: string, updates: Partial<InsertArticle>): Promise<Article> {
    const result = await db.update(articles)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(articles.id, id))
      .returning();
    return result[0];
  }

  async deleteArticle(id: string): Promise<void> {
    await db.delete(articles).where(eq(articles.id, id));
  }

  // Email Templates
  async createEmailTemplate(insertEmailTemplate: InsertEmailTemplate): Promise<EmailTemplate> {
    const result = await db.insert(emailTemplates).values(insertEmailTemplate).returning();
    return result[0];
  }

  async getEmailTemplates(category?: string): Promise<EmailTemplate[]> {
    if (category) {
      return await db.select().from(emailTemplates)
        .where(eq(emailTemplates.category, category))
        .orderBy(desc(emailTemplates.createdAt));
    }
    
    return await db.select().from(emailTemplates)
      .orderBy(desc(emailTemplates.createdAt));
  }

  async getEmailTemplateById(id: string): Promise<EmailTemplate | undefined> {
    const result = await db.select().from(emailTemplates).where(eq(emailTemplates.id, id)).limit(1);
    return result[0];
  }

  async getEmailTemplateByCategory(category: string): Promise<EmailTemplate | undefined> {
    const result = await db.select().from(emailTemplates)
      .where(and(
        eq(emailTemplates.category, category),
        eq(emailTemplates.isActive, true)
      ))
      .limit(1);
    return result[0];
  }

  async updateEmailTemplate(id: string, updates: Partial<InsertEmailTemplate>): Promise<EmailTemplate> {
    const result = await db.update(emailTemplates)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(emailTemplates.id, id))
      .returning();
    return result[0];
  }

  async deleteEmailTemplate(id: string): Promise<void> {
    await db.delete(emailTemplates).where(eq(emailTemplates.id, id));
  }

  // Email History
  async createEmailHistory(insertEmailHistory: InsertEmailHistory): Promise<EmailHistory> {
    const result = await db.insert(emailHistory).values(insertEmailHistory).returning();
    return result[0];
  }

  async getEmailHistory(limit = 50, status?: string): Promise<EmailHistory[]> {
    if (status) {
      return await db.select().from(emailHistory)
        .where(eq(emailHistory.status, status))
        .orderBy(desc(emailHistory.createdAt))
        .limit(limit);
    }
    
    return await db.select().from(emailHistory)
      .orderBy(desc(emailHistory.createdAt))
      .limit(limit);
  }

  async updateEmailHistoryStatus(id: string, status: string, errorMessage?: string): Promise<void> {
    const updates: { status: string; errorMessage?: string; sentAt?: Date } = { status };
    if (errorMessage) {
      updates.errorMessage = errorMessage;
    }
    if (status === 'sent') {
      updates.sentAt = new Date();
    }
    await db.update(emailHistory).set(updates).where(eq(emailHistory.id, id));
  }

  // Auth Sessions (2FA)
  async createAuthSession(session: InsertAuthSession): Promise<AuthSession> {
    // Since we're in memory mode, create a session object directly
    const newSession: AuthSession = {
      id: session.id || crypto.randomUUID(),
      email: session.email,
      phoneNumber: session.phoneNumber,
      isEmailVerified: session.isEmailVerified || false,
      isSmsVerified: session.isSmsVerified || false,
      verificationSid: session.verificationSid || null,
      expiresAt: session.expiresAt,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    // Store in memory (since database is not connected)
    this.memoryStore.authSessions.set(newSession.id, newSession);
    
    return newSession;
  }

  async getAuthSession(id: string): Promise<AuthSession | undefined> {
    // Get from memory store (since database is not connected)
    return this.memoryStore.authSessions.get(id);
  }

  async updateAuthSession(id: string, updates: Partial<InsertAuthSession>): Promise<void> {
    // Update in memory store (since database is not connected)
    const existing = this.memoryStore.authSessions.get(id);
    if (existing) {
      const updated = { ...existing, ...updates, updatedAt: new Date() };
      this.memoryStore.authSessions.set(id, updated);
    }
  }

  // Guides
  async createGuide(guide: InsertGuide): Promise<Guide> {
    const [newGuide] = await db
      .insert(guides)
      .values({ ...guide, updatedAt: new Date() })
      .returning();
    return newGuide;
  }

  async getGuides(persona?: string): Promise<Guide[]> {
    if (isDevelopmentMode) {
      // Return mock guides for development
      const mockGuides = [
        {
          id: 'dev-guide-presse',
          title: 'Guide du Vendeur PressÃ© en Gironde',
          slug: 'guide-vendeur-presse-gironde',
          persona: 'presse',
          shortBenefit: 'Vendez votre bien en moins de 90 jours grÃ¢ce Ã  nos stratÃ©gies Ã©prouvÃ©es',
          readingTime: 15,
          content: `<h1>Guide du Vendeur PressÃ© en Gironde</h1>
            <p>Vous devez vendre rapidement votre bien immobilier en Gironde ? Ce guide vous rÃ©vÃ¨le les stratÃ©gies qui fonctionnent dans un marchÃ© concurrentiel comme celui de Bordeaux et ses environs.</p>
            
            <h2>StratÃ©gies de pricing agressif</h2>
            <p>Le prix est votre arme principale. En Gironde, un bien correctement pricÃ© se vend 40% plus vite. DÃ©couvrez comment positionner votre prix pour attirer immÃ©diatement les acheteurs.</p>
            
            <h2>Home staging express</h2>
            <p>Valorisez votre bien en 48h chrono avec des techniques de home staging adaptÃ©es aux goÃ»ts bordelais. Investissement moyen : 500â‚¬ pour un gain de 15 000â‚¬.</p>
            
            <h2>RÃ©seau d'acheteurs qualifiÃ©s</h2>
            <p>AccÃ©dez Ã  notre rÃ©seau d'acheteurs prÃ©-qualifiÃ©s en Gironde. 60% de nos ventes se font hors marchÃ© public.</p>`,
          summary: 'Pricing stratÃ©gique â€¢ Home staging express â€¢ RÃ©seau acheteurs â€¢ NÃ©gociation rapide',
          imageUrl: 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=300&fit=crop&crop=center',
          metaDescription: 'Guide expert pour vendre rapidement votre bien immobilier en Gironde. StratÃ©gies Ã©prouvÃ©es, home staging, rÃ©seau acheteurs.',
          seoTitle: 'Guide Vendeur PressÃ© Gironde | Vendre en 90 jours',
          downloadCount: 125,
          isActive: true,
          sortOrder: 1,
          createdAt: new Date(),
          updatedAt: new Date()
        },
        {
          id: 'dev-guide-maximisateur',
          title: 'Guide du Maximisateur de Plus-Value',
          slug: 'guide-maximisateur-plus-value-gironde',
          persona: 'maximisateur',
          shortBenefit: 'Optimisez chaque euro de votre vente grÃ¢ce Ã  nos techniques de nÃ©gociation avancÃ©es',
          readingTime: 25,
          content: `<h1>Guide du Maximisateur de Plus-Value en Gironde</h1>
            <p>Vous voulez obtenir le meilleur prix pour votre bien ? Ce guide rÃ©vÃ¨le les techniques utilisÃ©es par les nÃ©gociateurs immobiliers d'Ã©lite en Gironde.</p>
            
            <h2>Valorisation maximale de votre bien</h2>
            <p>Identifiez tous les leviers de valorisation : travaux rentables, optimisation fiscale, timing parfait. En Gironde, ces techniques permettent de gagner entre 5% et 15% sur le prix de vente.</p>
            
            <h2>Psychologie de nÃ©gociation immobiliÃ¨re</h2>
            <p>MaÃ®trisez l'art de la nÃ©gociation avec les acheteurs girondins. Techniques de closing, gestion des objections, crÃ©ation d'urgence artificielle.</p>
            
            <h2>Analyse micro-marchÃ© Bordeaux MÃ©tropole</h2>
            <p>Exploitez les spÃ©cificitÃ©s de chaque quartier : Saint-Pierre, Chartrons, CaudÃ©ran... Maximisez selon votre localisation prÃ©cise.</p>`,
          summary: 'Valorisation maximale â€¢ NÃ©gociation avancÃ©e â€¢ Analyse micro-marchÃ© â€¢ ROI travaux â€¢ FiscalitÃ© optimisÃ©e',
          imageUrl: 'https://images.unsplash.com/photo-1560250097-0b93528c311a?w=400&h=300&fit=crop&crop=center',
          metaDescription: 'Guide expert maximisation plus-value immobiliÃ¨re Gironde. NÃ©gociation, valorisation, fiscalitÃ© optimisÃ©e.',
          seoTitle: 'Maximiser Plus-Value ImmobiliÃ¨re Gironde | Guide Expert',
          downloadCount: 89,
          isActive: true,
          sortOrder: 2,
          createdAt: new Date(),
          updatedAt: new Date()
        },
        {
          id: 'dev-guide-succession',
          title: 'Guide Succession ImmobiliÃ¨re Gironde',
          slug: 'guide-succession-immobiliere-gironde',
          persona: 'succession',
          shortBenefit: 'GÃ©rez sereinement la vente d\'un bien hÃ©ritÃ© avec nos conseils juridiques et pratiques',
          readingTime: 30,
          content: `<h1>Guide Succession ImmobiliÃ¨re en Gironde</h1>
            <p>Vendre un bien immobilier en succession nÃ©cessite des prÃ©cautions particuliÃ¨res. Ce guide vous accompagne dans chaque Ã©tape administrative et pratique.</p>
            
            <h2>DÃ©marches administratives succession</h2>
            <p>Check-list complÃ¨te : acte de notoriÃ©tÃ©, dÃ©claration de succession, autorisation de vendre. DÃ©lais et piÃ¨ges Ã  Ã©viter en Gironde.</p>
            
            <h2>Optimisation fiscale succession</h2>
            <p>Minimisez les droits de succession, optimisez l'abattement, gÃ©rez la plus-value. StratÃ©gies spÃ©cifiques aux biens girondins.</p>
            
            <h2>Gestion familiale et Ã©motionnelle</h2>
            <p>Conseils pour gÃ©rer les conflits familiaux, prendre des dÃ©cisions consensuelles, prÃ©server les relations tout en optimisant la vente.</p>
            
            <h2>Valorisation bien patrimoine</h2>
            <p>Techniques spÃ©cifiques pour les biens anciens, maisons de famille, propriÃ©tÃ©s viticoles typiques de la Gironde.</p>`,
          summary: 'DÃ©marches lÃ©gales â€¢ FiscalitÃ© succession â€¢ Gestion familiale â€¢ Valorisation patrimoine â€¢ Optimisation droits',
          imageUrl: 'https://images.unsplash.com/photo-1600880292203-757bb62b4baf?w=400&h=300&fit=crop&crop=center',
          metaDescription: 'Guide complet succession immobiliÃ¨re Gironde. DÃ©marches, fiscalitÃ©, gestion familiale, conseils notariaux.',
          seoTitle: 'Succession ImmobiliÃ¨re Gironde | Guide Complet 2025',
          downloadCount: 67,
          isActive: true,
          sortOrder: 3,
          createdAt: new Date(),
          updatedAt: new Date()
        },
        {
          id: 'dev-guide-nouvelle-vie',
          title: 'Guide Nouvelle Vie - Changement Immobilier',
          slug: 'guide-nouvelle-vie-changement-immobilier',
          persona: 'nouvelle_vie',
          shortBenefit: 'Accompagnement personnalisÃ© pour votre projet de vie : dÃ©mÃ©nagement, retraite, sÃ©paration',
          readingTime: 20,
          content: `<h1>Guide Nouvelle Vie - Changement Immobilier</h1>
            <p>Divorce, retraite, changement professionnel... Les transitions de vie nÃ©cessitent des stratÃ©gies immobiliÃ¨res adaptÃ©es. Ce guide vous accompagne dans votre nouveau dÃ©part.</p>
            
            <h2>StratÃ©gies selon votre situation</h2>
            <p>Retraite : optimiser pour la fiscalitÃ© et le cash-flow. Divorce : prÃ©server vos intÃ©rÃªts patrimoniaux. Mutation professionnelle : timing et nÃ©gociation employeur.</p>
            
            <h2>Recherche nouveau logement</h2>
            <p>CritÃ¨res adaptÃ©s Ã  votre nouvelle vie, quartiers recommandÃ©s en Gironde selon l'Ã¢ge et les besoins, budgÃ©tisation rÃ©aliste.</p>
            
            <h2>Accompagnement Ã©motionnel</h2>
            <p>GÃ©rer le stress du changement, prendre les bonnes dÃ©cisions, Ã©viter les erreurs dues Ã  l'Ã©motion. Support psychologique inclus.</p>
            
            <h2>Optimisation financiÃ¨re transition</h2>
            <p>CrÃ©dit relais, vente avant achat, nÃ©gociation des frais, solutions de financement transitoires.</p>`,
          summary: 'StratÃ©gies transition â€¢ Recherche logement â€¢ Support Ã©motionnel â€¢ Optimisation financiÃ¨re â€¢ Accompagnement personnalisÃ©',
          imageUrl: 'https://images.unsplash.com/photo-1573496359142-b8d87734a5a2?w=400&h=300&fit=crop&crop=center',
          metaDescription: 'Guide changement vie immobilier Gironde. Retraite, divorce, mutation : stratÃ©gies et accompagnement personnalisÃ©.',
          seoTitle: 'Changement Vie Immobilier Gironde | Guide Transition',
          downloadCount: 78,
          isActive: true,
          sortOrder: 4,
          createdAt: new Date(),
          updatedAt: new Date()
        },
        {
          id: 'dev-guide-investisseur',
          title: 'Guide de l\'Investisseur Immobilier Gironde',
          slug: 'guide-investisseur-immobilier-gironde',
          persona: 'investisseur',
          shortBenefit: 'Maximisez votre ROI avec les meilleures opportunitÃ©s d\'investissement en Gironde',
          readingTime: 35,
          content: `<h1>Guide de l'Investisseur Immobilier en Gironde</h1>
            <p>Investir dans l'immobilier girondin nÃ©cessite une connaissance fine du marchÃ© local. Ce guide rÃ©vÃ¨le les stratÃ©gies des investisseurs qui rÃ©ussissent.</p>
            
            <h2>Analyse marchÃ© Bordeaux MÃ©tropole</h2>
            <p>Zones en dÃ©veloppement, projets urbains 2025-2030, Ã©volution des prix par secteur, identification des futures pÃ©pites immobiliÃ¨res.</p>
            
            <h2>StratÃ©gies fiscales optimisÃ©es</h2>
            <p>Pinel, Malraux, dÃ©fiscalisation, SCI : choisir la meilleure structure selon votre profil fiscal et vos objectifs de rentabilitÃ©.</p>
            
            <h2>Calculs de rentabilitÃ© prÃ©cis</h2>
            <p>Cash-flow, rentabilitÃ© nette, impact fiscal, coÃ»ts cachÃ©s, seuils de rentabilitÃ© par type de bien et quartier en Gironde.</p>
            
            <h2>NÃ©gociation investisseur</h2>
            <p>Techniques de nÃ©gociation spÃ©cifiques aux investissements, identification des biens dÃ©cotÃ©s, nÃ©gociation avec les promoteurs.</p>
            
            <h2>Gestion locative optimisÃ©e</h2>
            <p>SÃ©lection locataires, optimisation loyers, gestion des impayÃ©s, stratÃ©gies de plus-value Ã  moyen terme.</p>`,
          summary: 'Analyse marchÃ© â€¢ FiscalitÃ© optimisÃ©e â€¢ Calculs rentabilitÃ© â€¢ NÃ©gociation â€¢ Gestion locative â€¢ StratÃ©gies ROI',
          imageUrl: 'https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=400&h=300&fit=crop&crop=center',
          metaDescription: 'Guide investissement immobilier Gironde. ROI, fiscalitÃ©, analyse marchÃ©, nÃ©gociation, gestion locative.',
          seoTitle: 'Investissement Immobilier Gironde | Guide ROI 2025',
          downloadCount: 156,
          isActive: true,
          sortOrder: 5,
          createdAt: new Date(),
          updatedAt: new Date()
        },
        {
          id: 'dev-guide-primo',
          title: 'Guide du Primo-Vendeur en Gironde',
          slug: 'guide-primo-vendeur-gironde',
          persona: 'primo',
          shortBenefit: 'Votre premiÃ¨re vente immobiliÃ¨re expliquÃ©e Ã©tape par Ã©tape, sans stress ni piÃ¨ge',
          readingTime: 18,
          content: `<h1>Guide du Primo-Vendeur en Gironde</h1>
            <p>PremiÃ¨re vente immobiliÃ¨re ? Ce guide vous accompagne pas Ã  pas pour Ã©viter les erreurs et optimiser votre transaction en toute sÃ©rÃ©nitÃ©.</p>
            
            <h2>Ã‰tapes de la vente immobiliÃ¨re</h2>
            <p>Chronologie complÃ¨te : de l'estimation Ã  la signature chez le notaire. Check-list dÃ©taillÃ©e, dÃ©lais Ã  respecter, documents Ã  prÃ©parer.</p>
            
            <h2>Estimation juste de votre bien</h2>
            <p>MÃ©thodes d'estimation, erreurs courantes des primo-vendeurs, importance du prix juste, comparaison avec le marchÃ© girondin.</p>
            
            <h2>Choisir son professionnel</h2>
            <p>Agent immobilier vs vente directe : avantages/inconvÃ©nients. Comment sÃ©lectionner le bon partenaire en Gironde.</p>
            
            <h2>NÃ©gociation pour dÃ©butants</h2>
            <p>Bases de la nÃ©gociation immobiliÃ¨re, rÃ©pondre aux objections courantes, Ã©viter les erreurs qui coÃ»tent cher.</p>
            
            <h2>Aspects juridiques simplifiÃ©s</h2>
            <p>Diagnostics obligatoires, compromis de vente, conditions suspensives. Tout comprendre sans jargon juridique.</p>`,
          summary: 'Ã‰tapes vente â€¢ Estimation juste â€¢ Choix professionnel â€¢ NÃ©gociation basics â€¢ Juridique simplifiÃ© â€¢ Ã‰viter piÃ¨ges',
          imageUrl: 'https://images.unsplash.com/photo-1438761681033-6461ffad8d80?w=400&h=300&fit=crop&crop=center',
          metaDescription: 'Guide premiÃ¨re vente immobiliÃ¨re Gironde. Ã‰tapes, estimation, nÃ©gociation, conseils primo-vendeur.',
          seoTitle: 'Primo-Vendeur Immobilier Gironde | Guide PremiÃ¨re Vente',
          downloadCount: 203,
          isActive: true,
          sortOrder: 6,
          createdAt: new Date(),
          updatedAt: new Date()
        }
      ];
      
      return mockGuides.filter(g => !persona || g.persona === persona);
    }
    
    if (persona) {
      return await db
        .select()
        .from(guides)
        .where(and(eq(guides.isActive, true), eq(guides.persona, persona)))
        .orderBy(guides.sortOrder, guides.createdAt);
    }
    
    return await db
      .select()
      .from(guides)
      .where(eq(guides.isActive, true))
      .orderBy(guides.sortOrder, guides.createdAt);
  }

  async getGuideById(id: string): Promise<Guide | undefined> {
    const [guide] = await db
      .select()
      .from(guides)
      .where(and(eq(guides.id, id), eq(guides.isActive, true)))
      .limit(1);
    return guide;
  }

  async getGuideBySlug(slug: string): Promise<Guide | undefined> {
    const [guide] = await db
      .select()
      .from(guides)
      .where(and(eq(guides.slug, slug), eq(guides.isActive, true)))
      .limit(1);
    return guide;
  }

  async updateGuide(id: string, updates: Partial<InsertGuide>): Promise<Guide> {
    const [updatedGuide] = await db
      .update(guides)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(guides.id, id))
      .returning();
    return updatedGuide;
  }

  async deleteGuide(id: string): Promise<void> {
    await db.delete(guides).where(eq(guides.id, id));
  }

  // Guide Downloads & Analytics
  async createGuideDownload(download: InsertGuideDownload): Promise<GuideDownload> {
    const [newDownload] = await db
      .insert(guideDownloads)
      .values(download)
      .returning();
    return newDownload;
  }

  async getGuideDownloads(guideId?: string): Promise<GuideDownload[]> {
    if (guideId) {
      return await db
        .select()
        .from(guideDownloads)
        .where(eq(guideDownloads.guideId, guideId))
        .orderBy(desc(guideDownloads.downloadedAt));
    }
    
    return await db
      .select()
      .from(guideDownloads)
      .orderBy(desc(guideDownloads.downloadedAt));
  }

  async createGuideAnalytics(analytics: InsertGuideAnalytics): Promise<GuideAnalytics> {
    const [newAnalytics] = await db
      .insert(guideAnalytics)
      .values(analytics)
      .returning();
    return newAnalytics;
  }

  async getGuideAnalytics(guideId: string): Promise<GuideAnalytics[]> {
    return await db
      .select()
      .from(guideAnalytics)
      .where(eq(guideAnalytics.guideId, guideId))
      .orderBy(desc(guideAnalytics.timestamp));
  }

  // Guide Email Sequences
  async createGuideEmailSequence(sequence: InsertGuideEmailSequence): Promise<GuideEmailSequence> {
    const [newSequence] = await db
      .insert(guideEmailSequences)
      .values(sequence)
      .returning();
    return newSequence;
  }

  async getGuideEmailSequences(leadEmail?: string): Promise<GuideEmailSequence[]> {
    if (leadEmail) {
      return await db
        .select()
        .from(guideEmailSequences)
        .where(eq(guideEmailSequences.leadEmail, leadEmail))
        .orderBy(desc(guideEmailSequences.createdAt));
    }
    
    return await db
      .select()
      .from(guideEmailSequences)
      .orderBy(desc(guideEmailSequences.createdAt));
  }

  async updateGuideEmailSequence(id: string, updates: Partial<InsertGuideEmailSequence>): Promise<void> {
    await db
      .update(guideEmailSequences)
      .set(updates)
      .where(eq(guideEmailSequences.id, id));
  }

  // Persona Configurations
  async getPersonaConfigs(): Promise<PersonaConfigData[]> {
    return await db
      .select()
      .from(personaConfigs)
      .orderBy(personaConfigs.createdAt);
  }

  async getPersonaConfigByPersona(persona: string): Promise<PersonaConfigData | undefined> {
    const [config] = await db
      .select()
      .from(personaConfigs)
      .where(eq(personaConfigs.persona, persona))
      .limit(1);
    return config;
  }

  async createPersonaConfig(config: InsertPersonaConfig): Promise<PersonaConfigData> {
    const [newConfig] = await db
      .insert(personaConfigs)
      .values({ ...config, updatedAt: new Date() })
      .returning();
    return newConfig;
  }

  async updatePersonaConfig(persona: string, updates: Partial<InsertPersonaConfig>): Promise<PersonaConfigData> {
    const [updatedConfig] = await db
      .update(personaConfigs)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(personaConfigs.persona, persona))
      .returning();
    return updatedConfig;
  }

  // Lead Scoring
  async createLeadScoring(scoring: InsertLeadScoring): Promise<LeadScoring> {
    const [newScoring] = await db
      .insert(leadScoring)
      .values({ ...scoring, updatedAt: new Date() })
      .returning();
    return newScoring;
  }

  async getLeadScoring(leadId: string): Promise<LeadScoring | undefined> {
    const [scoring] = await db
      .select()
      .from(leadScoring)
      .where(eq(leadScoring.leadId, leadId))
      .limit(1);
    return scoring;
  }

  async getLeadScoringByIds(leadIds: string[]): Promise<LeadScoring[]> {
    return await db
      .select()
      .from(leadScoring)
      .where(sql`${leadScoring.leadId} = ANY(${leadIds})`);
  }

  async updateLeadScoring(leadId: string, updates: Partial<InsertLeadScoring>): Promise<LeadScoring> {
    const [updatedScoring] = await db
      .update(leadScoring)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(leadScoring.leadId, leadId))
      .returning();
    return updatedScoring;
  }

  async getAllLeadScoring(limit = 100, qualificationStatus?: string): Promise<LeadScoring[]> {
    let query = db.select().from(leadScoring);
    
    if (qualificationStatus) {
      query = query.where(eq(leadScoring.qualificationStatus, qualificationStatus));
    }
    
    return await query
      .orderBy(desc(leadScoring.totalScore))
      .limit(limit);
  }

  // Scoring Configuration
  async createScoringConfig(config: InsertScoringConfig): Promise<ScoringConfig> {
    const [newConfig] = await db
      .insert(scoringConfig)
      .values({ ...config, updatedAt: new Date() })
      .returning();
    return newConfig;
  }

  async getScoringConfigs(): Promise<ScoringConfig[]> {
    return await db
      .select()
      .from(scoringConfig)
      .where(eq(scoringConfig.isActive, true))
      .orderBy(scoringConfig.criteriaType);
  }

  async getScoringConfigByCriteria(criteriaType: string): Promise<ScoringConfig | undefined> {
    const [config] = await db
      .select()
      .from(scoringConfig)
      .where(and(
        eq(scoringConfig.criteriaType, criteriaType),
        eq(scoringConfig.isActive, true)
      ))
      .limit(1);
    return config;
  }

  async updateScoringConfig(id: string, updates: Partial<InsertScoringConfig>): Promise<ScoringConfig> {
    const [updatedConfig] = await db
      .update(scoringConfig)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(scoringConfig.id, id))
      .returning();
    return updatedConfig;
  }

  async deleteScoringConfig(id: string): Promise<void> {
    await db
      .delete(scoringConfig)
      .where(eq(scoringConfig.id, id));
  }

  // Lead Score History
  async createLeadScoreHistory(history: InsertLeadScoreHistory): Promise<LeadScoreHistory> {
    const [newHistory] = await db
      .insert(leadScoreHistory)
      .values(history)
      .returning();
    return newHistory;
  }

  async getLeadScoreHistory(leadId: string): Promise<LeadScoreHistory[]> {
    return await db
      .select()
      .from(leadScoreHistory)
      .where(eq(leadScoreHistory.leadId, leadId))
      .orderBy(desc(leadScoreHistory.createdAt));
  }

  async getAllScoreHistory(limit = 100): Promise<LeadScoreHistory[]> {
    return await db
      .select()
      .from(leadScoreHistory)
      .orderBy(desc(leadScoreHistory.createdAt))
      .limit(limit);
  }

  // Lead Scoring Analytics
  async getLeadScoringStats(startDate?: Date, endDate?: Date): Promise<{
    totalLeads: number;
    averageScore: number;
    qualifiedLeads: number;
    qualificationRate: number;
    hotLeads: number;
    conversionRate: number;
  }> {
    let query = db.select({
      totalLeads: sql`COUNT(*)`,
      averageScore: sql`AVG(${leadScoring.totalScore})`,
      qualifiedLeads: sql`COUNT(*) FILTER (WHERE ${leadScoring.qualificationStatus} IN ('qualified', 'hot_lead'))`,
      hotLeads: sql`COUNT(*) FILTER (WHERE ${leadScoring.qualificationStatus} = 'hot_lead')`
    }).from(leadScoring);

    if (startDate) {
      query = query.where(sql`${leadScoring.createdAt} >= ${startDate}`);
    }
    if (endDate) {
      query = query.where(sql`${leadScoring.createdAt} <= ${endDate}`);
    }

    const [stats] = await query;
    
    const totalLeads = Number(stats.totalLeads) || 0;
    const qualifiedLeads = Number(stats.qualifiedLeads) || 0;
    const hotLeads = Number(stats.hotLeads) || 0;
    
    return {
      totalLeads,
      averageScore: Number(stats.averageScore) || 0,
      qualifiedLeads,
      qualificationRate: totalLeads > 0 ? (qualifiedLeads / totalLeads) * 100 : 0,
      hotLeads,
      conversionRate: totalLeads > 0 ? (hotLeads / totalLeads) * 100 : 0
    };
  }

  async getScoreDistribution(): Promise<Array<{
    range: string;
    count: number;
    percentage: number;
  }>> {
    const distribution = await db.select({
      range: sql`
        CASE 
          WHEN ${leadScoring.totalScore} >= 76 THEN '76-100'
          WHEN ${leadScoring.totalScore} >= 51 THEN '51-75'
          WHEN ${leadScoring.totalScore} >= 26 THEN '26-50'
          ELSE '0-25'
        END
      `,
      count: sql`COUNT(*)`
    })
    .from(leadScoring)
    .groupBy(sql`
      CASE 
        WHEN ${leadScoring.totalScore} >= 76 THEN '76-100'
        WHEN ${leadScoring.totalScore} >= 51 THEN '51-75'
        WHEN ${leadScoring.totalScore} >= 26 THEN '26-50'
        ELSE '0-25'
      END
    `);

    const total = distribution.reduce((sum, item) => sum + Number(item.count), 0);
    
    return distribution.map(item => ({
      range: String(item.range),
      count: Number(item.count),
      percentage: total > 0 ? (Number(item.count) / total) * 100 : 0
    }));
  }

  async getBantBreakdown(): Promise<{
    budget: { average: number; distribution: Record<string, number> };
    authority: { average: number; distribution: Record<string, number> };
    need: { average: number; distribution: Record<string, number> };
    timeline: { average: number; distribution: Record<string, number> };
  }> {
    const [averages] = await db.select({
      budgetAvg: sql`AVG(${leadScoring.budgetScore})`,
      authorityAvg: sql`AVG(${leadScoring.authorityScore})`,
      needAvg: sql`AVG(${leadScoring.needScore})`,
      timelineAvg: sql`AVG(${leadScoring.timelineScore})`
    }).from(leadScoring);

    // Get distributions for each criteria
    const budgetDist = await db.select({
      score: leadScoring.budgetScore,
      count: sql`COUNT(*)`
    })
    .from(leadScoring)
    .groupBy(leadScoring.budgetScore);

    const authorityDist = await db.select({
      score: leadScoring.authorityScore,
      count: sql`COUNT(*)`
    })
    .from(leadScoring)
    .groupBy(leadScoring.authorityScore);

    const needDist = await db.select({
      score: leadScoring.needScore,
      count: sql`COUNT(*)`
    })
    .from(leadScoring)
    .groupBy(leadScoring.needScore);

    const timelineDist = await db.select({
      score: leadScoring.timelineScore,
      count: sql`COUNT(*)`
    })
    .from(leadScoring)
    .groupBy(leadScoring.timelineScore);

    const formatDistribution = (dist: any[]) => {
      const result: Record<string, number> = {};
      dist.forEach(item => {
        result[String(item.score || 0)] = Number(item.count);
      });
      return result;
    };

    return {
      budget: {
        average: Number(averages.budgetAvg) || 0,
        distribution: formatDistribution(budgetDist)
      },
      authority: {
        average: Number(averages.authorityAvg) || 0,
        distribution: formatDistribution(authorityDist)
      },
      need: {
        average: Number(averages.needAvg) || 0,
        distribution: formatDistribution(needDist)
      },
      timeline: {
        average: Number(averages.timelineAvg) || 0,
        distribution: formatDistribution(timelineDist)
      }
    };
  }

  // SMS Campaigns Implementation
  async createSmsCampaign(insertCampaign: InsertSmsCampaign): Promise<SmsCampaign> {
    const result = await db.insert(smsCampaigns).values(insertCampaign).returning();
    return result[0];
  }

  async getSmsCampaigns(status?: string, limit = 50): Promise<SmsCampaign[]> {
    let query = db.select().from(smsCampaigns);
    
    if (status) {
      query = query.where(eq(smsCampaigns.status, status));
    }
    
    return await query.orderBy(desc(smsCampaigns.createdAt)).limit(limit);
  }

  async getSmsCampaignById(id: string): Promise<SmsCampaign | undefined> {
    const result = await db.select().from(smsCampaigns).where(eq(smsCampaigns.id, id)).limit(1);
    return result[0];
  }

  async updateSmsCampaign(id: string, updates: Partial<InsertSmsCampaign>): Promise<SmsCampaign> {
    const result = await db
      .update(smsCampaigns)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(smsCampaigns.id, id))
      .returning();
    return result[0];
  }

  async deleteSmsCampaign(id: string): Promise<void> {
    await db.delete(smsCampaigns).where(eq(smsCampaigns.id, id));
  }

  async updateSmsCampaignStats(id: string, stats: {
    sentCount?: number;
    deliveredCount?: number;
    failedCount?: number;
    clickedCount?: number;
    unsubscribedCount?: number;
    conversionCount?: number;
    actualCost?: string;
    roi?: string;
  }): Promise<void> {
    await db
      .update(smsCampaigns)
      .set({ ...stats, updatedAt: new Date() })
      .where(eq(smsCampaigns.id, id));
  }

  // SMS Templates Implementation
  async createSmsTemplate(insertTemplate: InsertSmsTemplate): Promise<SmsTemplate> {
    const result = await db.insert(smsTemplates).values(insertTemplate).returning();
    return result[0];
  }

  async getSmsTemplates(category?: string, persona?: string, isActive?: boolean): Promise<SmsTemplate[]> {
    let query = db.select().from(smsTemplates);
    const conditions = [];

    if (category) {
      conditions.push(eq(smsTemplates.category, category));
    }
    if (persona) {
      conditions.push(eq(smsTemplates.persona, persona));
    }
    if (isActive !== undefined) {
      conditions.push(eq(smsTemplates.isActive, isActive));
    }

    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }

    return await query.orderBy(desc(smsTemplates.updatedAt));
  }

  async getSmsTemplateById(id: string): Promise<SmsTemplate | undefined> {
    const result = await db.select().from(smsTemplates).where(eq(smsTemplates.id, id)).limit(1);
    return result[0];
  }

  async updateSmsTemplate(id: string, updates: Partial<InsertSmsTemplate>): Promise<SmsTemplate> {
    const result = await db
      .update(smsTemplates)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(smsTemplates.id, id))
      .returning();
    return result[0];
  }

  async deleteSmsTemplate(id: string): Promise<void> {
    await db.delete(smsTemplates).where(eq(smsTemplates.id, id));
  }

  async incrementSmsTemplateUsage(id: string): Promise<void> {
    await db
      .update(smsTemplates)
      .set({ 
        usageCount: sql`${smsTemplates.usageCount} + 1`,
        lastUsed: new Date(),
        updatedAt: new Date()
      })
      .where(eq(smsTemplates.id, id));
  }

  // SMS Contacts Implementation
  async createSmsContact(insertContact: InsertSmsContact): Promise<SmsContact> {
    const result = await db.insert(smsContacts).values(insertContact).returning();
    return result[0];
  }

  async getSmsContacts(persona?: string, isOptedIn?: boolean, limit = 100): Promise<SmsContact[]> {
    let query = db.select().from(smsContacts);
    const conditions = [];

    if (persona) {
      conditions.push(eq(smsContacts.persona, persona));
    }
    if (isOptedIn !== undefined) {
      conditions.push(eq(smsContacts.isOptedIn, isOptedIn));
    }

    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }

    return await query.orderBy(desc(smsContacts.createdAt)).limit(limit);
  }

  async getSmsContactById(id: string): Promise<SmsContact | undefined> {
    const result = await db.select().from(smsContacts).where(eq(smsContacts.id, id)).limit(1);
    return result[0];
  }

  async getSmsContactByPhone(phoneNumber: string): Promise<SmsContact | undefined> {
    const result = await db.select().from(smsContacts).where(eq(smsContacts.phoneNumber, phoneNumber)).limit(1);
    return result[0];
  }

  async updateSmsContact(id: string, updates: Partial<InsertSmsContact>): Promise<SmsContact> {
    const result = await db
      .update(smsContacts)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(smsContacts.id, id))
      .returning();
    return result[0];
  }

  async deleteSmsContact(id: string): Promise<void> {
    await db.delete(smsContacts).where(eq(smsContacts.id, id));
  }

  async optOutSmsContact(phoneNumber: string, reason?: string): Promise<void> {
    await db
      .update(smsContacts)
      .set({ 
        isOptedIn: false, 
        optOutDate: new Date(),
        optOutReason: reason,
        updatedAt: new Date()
      })
      .where(eq(smsContacts.phoneNumber, phoneNumber));
  }

  async updateSmsContactStats(id: string, stats: {
    totalMessagesSent?: number;
    totalMessagesDelivered?: number;
    totalMessagesClicked?: number;
    conversionCount?: number;
    lastContactDate?: Date;
  }): Promise<void> {
    await db
      .update(smsContacts)
      .set({ ...stats, updatedAt: new Date() })
      .where(eq(smsContacts.id, id));
  }

  // SMS Sent Messages Implementation
  async createSmsSentMessage(insertMessage: InsertSmsSentMessage): Promise<SmsSentMessage> {
    const result = await db.insert(smsSentMessages).values(insertMessage).returning();
    return result[0];
  }

  async getSmsSentMessages(campaignId?: string, contactId?: string, status?: string, limit = 100): Promise<SmsSentMessage[]> {
    let query = db.select().from(smsSentMessages);
    const conditions = [];

    if (campaignId) {
      conditions.push(eq(smsSentMessages.campaignId, campaignId));
    }
    if (contactId) {
      conditions.push(eq(smsSentMessages.contactId, contactId));
    }
    if (status) {
      conditions.push(eq(smsSentMessages.status, status));
    }

    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }

    return await query.orderBy(desc(smsSentMessages.createdAt)).limit(limit);
  }

  async getSmsSentMessageById(id: string): Promise<SmsSentMessage | undefined> {
    const result = await db.select().from(smsSentMessages).where(eq(smsSentMessages.id, id)).limit(1);
    return result[0];
  }

  async updateSmsSentMessage(id: string, updates: Partial<InsertSmsSentMessage>): Promise<SmsSentMessage> {
    const result = await db
      .update(smsSentMessages)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(smsSentMessages.id, id))
      .returning();
    return result[0];
  }

  async updateSmsSentMessageStatus(id: string, status: string, twilioData?: any): Promise<void> {
    const updateData: any = { 
      status, 
      updatedAt: new Date() 
    };

    if (twilioData) {
      updateData.webhookData = JSON.stringify(twilioData);
      
      if (status === 'sent') {
        updateData.sentAt = new Date();
      } else if (status === 'delivered') {
        updateData.deliveredAt = new Date();
      } else if (status === 'failed') {
        updateData.failedAt = new Date();
        updateData.errorMessage = twilioData.errorMessage;
        updateData.errorCode = twilioData.errorCode;
      }
    }

    await db.update(smsSentMessages).set(updateData).where(eq(smsSentMessages.id, id));
  }

  // SMS Sequences Implementation
  async createSmsSequence(insertSequence: InsertSmsSequence): Promise<SmsSequence> {
    const result = await db.insert(smsSequences).values(insertSequence).returning();
    return result[0];
  }

  async getSmsSequences(isActive?: boolean, trigger?: string): Promise<SmsSequence[]> {
    let query = db.select().from(smsSequences);
    const conditions = [];

    if (isActive !== undefined) {
      conditions.push(eq(smsSequences.isActive, isActive));
    }
    if (trigger) {
      conditions.push(eq(smsSequences.trigger, trigger));
    }

    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }

    return await query.orderBy(desc(smsSequences.createdAt));
  }

  async getSmsSequenceById(id: string): Promise<SmsSequence | undefined> {
    const result = await db.select().from(smsSequences).where(eq(smsSequences.id, id)).limit(1);
    return result[0];
  }

  async updateSmsSequence(id: string, updates: Partial<InsertSmsSequence>): Promise<SmsSequence> {
    const result = await db
      .update(smsSequences)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(smsSequences.id, id))
      .returning();
    return result[0];
  }

  async deleteSmsSequence(id: string): Promise<void> {
    await db.delete(smsSequences).where(eq(smsSequences.id, id));
  }

  // SMS Sequence Enrollments Implementation
  async createSmsSequenceEnrollment(insertEnrollment: InsertSmsSequenceEnrollment): Promise<SmsSequenceEnrollment> {
    const result = await db.insert(smsSequenceEnrollments).values(insertEnrollment).returning();
    return result[0];
  }

  async getSmsSequenceEnrollments(sequenceId?: string, contactId?: string, status?: string): Promise<SmsSequenceEnrollment[]> {
    let query = db.select().from(smsSequenceEnrollments);
    const conditions = [];

    if (sequenceId) {
      conditions.push(eq(smsSequenceEnrollments.sequenceId, sequenceId));
    }
    if (contactId) {
      conditions.push(eq(smsSequenceEnrollments.contactId, contactId));
    }
    if (status) {
      conditions.push(eq(smsSequenceEnrollments.status, status));
    }

    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }

    return await query.orderBy(desc(smsSequenceEnrollments.createdAt));
  }

  async updateSmsSequenceEnrollment(id: string, updates: Partial<InsertSmsSequenceEnrollment>): Promise<SmsSequenceEnrollment> {
    const result = await db
      .update(smsSequenceEnrollments)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(smsSequenceEnrollments.id, id))
      .returning();
    return result[0];
  }

  async getActiveSequenceEnrollments(): Promise<SmsSequenceEnrollment[]> {
    return await db
      .select()
      .from(smsSequenceEnrollments)
      .where(and(
        eq(smsSequenceEnrollments.status, 'active'),
        sql`${smsSequenceEnrollments.nextScheduledAt} <= NOW()`
      ))
      .orderBy(smsSequenceEnrollments.nextScheduledAt);
  }

  // SMS Analytics Implementation
  async getSmsAnalyticsOverview(startDate?: Date, endDate?: Date): Promise<{
    totalCampaigns: number;
    activeCampaigns: number;
    totalMessagesSent: number;
    totalMessagesDelivered: number;
    totalMessagesClicked: number;
    totalUnsubscribes: number;
    deliveryRate: number;
    clickRate: number;
    unsubscribeRate: number;
    totalCost: number;
    averageCostPerMessage: number;
    totalConversions: number;
    conversionRate: number;
    roi: number;
  }> {
    let campaignsQuery = db.select({
      totalCampaigns: sql`COUNT(*)`,
      activeCampaigns: sql`COUNT(*) FILTER (WHERE ${smsCampaigns.status} IN ('sending', 'scheduled'))`
    }).from(smsCampaigns);

    let messagesQuery = db.select({
      totalMessagesSent: sql`COUNT(*)`,
      totalMessagesDelivered: sql`COUNT(*) FILTER (WHERE ${smsSentMessages.status} = 'delivered')`,
      totalMessagesClicked: sql`COUNT(*) FILTER (WHERE ${smsSentMessages.status} = 'clicked')`,
      totalUnsubscribes: sql`COUNT(*) FILTER (WHERE ${smsSentMessages.status} = 'unsubscribed')`,
      totalCost: sql`SUM(${smsSentMessages.cost})`,
      totalConversions: sql`COUNT(*) FILTER (WHERE ${smsSentMessages.conversionTracked} = true)`
    }).from(smsSentMessages);

    if (startDate) {
      campaignsQuery = campaignsQuery.where(sql`${smsCampaigns.createdAt} >= ${startDate}`);
      messagesQuery = messagesQuery.where(sql`${smsSentMessages.createdAt} >= ${startDate}`);
    }
    if (endDate) {
      campaignsQuery = campaignsQuery.where(sql`${smsCampaigns.createdAt} <= ${endDate}`);
      messagesQuery = messagesQuery.where(sql`${smsSentMessages.createdAt} <= ${endDate}`);
    }

    const [campaignStats] = await campaignsQuery;
    const [messageStats] = await messagesQuery;

    const totalCampaigns = Number(campaignStats.totalCampaigns) || 0;
    const activeCampaigns = Number(campaignStats.activeCampaigns) || 0;
    const totalMessagesSent = Number(messageStats.totalMessagesSent) || 0;
    const totalMessagesDelivered = Number(messageStats.totalMessagesDelivered) || 0;
    const totalMessagesClicked = Number(messageStats.totalMessagesClicked) || 0;
    const totalUnsubscribes = Number(messageStats.totalUnsubscribes) || 0;
    const totalCost = Number(messageStats.totalCost) || 0;
    const totalConversions = Number(messageStats.totalConversions) || 0;

    return {
      totalCampaigns,
      activeCampaigns,
      totalMessagesSent,
      totalMessagesDelivered,
      totalMessagesClicked,
      totalUnsubscribes,
      deliveryRate: totalMessagesSent > 0 ? (totalMessagesDelivered / totalMessagesSent) * 100 : 0,
      clickRate: totalMessagesDelivered > 0 ? (totalMessagesClicked / totalMessagesDelivered) * 100 : 0,
      unsubscribeRate: totalMessagesSent > 0 ? (totalUnsubscribes / totalMessagesSent) * 100 : 0,
      totalCost,
      averageCostPerMessage: totalMessagesSent > 0 ? totalCost / totalMessagesSent : 0,
      totalConversions,
      conversionRate: totalMessagesSent > 0 ? (totalConversions / totalMessagesSent) * 100 : 0,
      roi: totalCost > 0 ? ((totalConversions * 1000) - totalCost) / totalCost * 100 : 0 // Assuming 1000â‚¬ average conversion value
    };
  }

  async getSmsCampaignPerformance(startDate?: Date, endDate?: Date): Promise<Array<{
    id: string;
    name: string;
    status: string;
    sent: number;
    delivered: number;
    clicked: number;
    conversions: number;
    deliveryRate: number;
    clickRate: number;
    conversionRate: number;
    cost: number;
    roi: number;
    createdAt: string;
  }>> {
    let query = db.select().from(smsCampaigns);

    if (startDate) {
      query = query.where(sql`${smsCampaigns.createdAt} >= ${startDate}`);
    }
    if (endDate) {
      query = query.where(sql`${smsCampaigns.createdAt} <= ${endDate}`);
    }

    const campaigns = await query.orderBy(desc(smsCampaigns.createdAt));

    return campaigns.map(campaign => ({
      id: campaign.id,
      name: campaign.name,
      status: campaign.status,
      sent: campaign.sentCount || 0,
      delivered: campaign.deliveredCount || 0,
      clicked: campaign.clickedCount || 0,
      conversions: campaign.conversionCount || 0,
      deliveryRate: campaign.sentCount ? (campaign.deliveredCount / campaign.sentCount) * 100 : 0,
      clickRate: campaign.deliveredCount ? (campaign.clickedCount / campaign.deliveredCount) * 100 : 0,
      conversionRate: campaign.sentCount ? (campaign.conversionCount / campaign.sentCount) * 100 : 0,
      cost: Number(campaign.actualCost) || 0,
      roi: Number(campaign.roi) || 0,
      createdAt: campaign.createdAt?.toISOString() || ''
    }));
  }

  async getSmsTemplatePerformance(): Promise<Array<{
    id: string;
    name: string;
    category: string;
    usageCount: number;
    conversionRate: number;
    averageClickRate: number;
    lastUsed?: string;
  }>> {
    const templates = await db.select().from(smsTemplates).orderBy(desc(smsTemplates.usageCount));

    return templates.map(template => ({
      id: template.id,
      name: template.name,
      category: template.category,
      usageCount: template.usageCount || 0,
      conversionRate: Number(template.conversionRate) || 0,
      averageClickRate: 0, // Would need complex query to calculate from sent messages
      lastUsed: template.lastUsed?.toISOString()
    }));
  }
}

export const storage = new SupabaseStorage();