import { supabaseAdmin } from '../server/lib/supabaseAdmin';
import { sql } from 'drizzle-orm';
import postgres from 'postgres';

// Script de migration CRITIQUE : PostgreSQL local ‚Üí Supabase
// SAUVEGARDE toutes les donn√©es avant suppression Neon

interface MigrationStats {
  users: { existing: number; migrated: number; errors: number };
  leads: { existing: number; migrated: number; errors: number };
  estimations: { existing: number; migrated: number; errors: number };
  contacts: { existing: number; migrated: number; errors: number };
  email_templates: { existing: number; migrated: number; errors: number };
}

// Configuration base locale (√† adapter si n√©cessaire)
const LOCAL_DB_URL = process.env.DATABASE_URL || process.env.NEON_DATABASE_URL;

async function connectToLocalDB() {
  if (!LOCAL_DB_URL) {
    throw new Error('‚ùå DATABASE_URL non configur√©e - impossible d\'acc√©der aux donn√©es locales');
  }
  
  try {
    const localDb = postgres(LOCAL_DB_URL, { ssl: 'prefer' });
    console.log('‚úÖ Connexion base locale r√©ussie');
    return localDb;
  } catch (error) {
    console.error('‚ùå Erreur connexion base locale:', error);
    throw error;
  }
}

async function migrateUsers(localDb: postgres.Sql, stats: MigrationStats) {
  console.log('\nüîÑ Migration table USERS...');
  
  try {
    // R√©cup√©rer les users locaux
    const localUsers = await localDb`SELECT * FROM users ORDER BY created_at DESC`;
    stats.users.existing = localUsers.length;
    console.log(`üìä ${localUsers.length} user(s) trouv√©(s) en local`);
    
    if (localUsers.length === 0) {
      console.log('‚ÑπÔ∏è Aucun user √† migrer');
      return;
    }
    
    // V√©rifier users existants Supabase
    const { data: existingUsers } = await supabaseAdmin
      .from('users')
      .select('username');
    
    const existingUsernames = new Set(existingUsers?.map(u => u.username) || []);
    
    // Migrer chaque user
    for (const user of localUsers) {
      try {
        if (existingUsernames.has(user.username)) {
          console.log(`‚ö†Ô∏è User "${user.username}" existe d√©j√† - ignor√©`);
          continue;
        }
        
        const userToMigrate = {
          id: user.id,
          username: user.username,
          password: user.password, // Hash d√©j√† stock√©
          role: user.role || 'admin',
          created_at: user.created_at
        };
        
        const { error } = await supabaseAdmin
          .from('users')
          .insert(userToMigrate);
        
        if (error) {
          console.error(`‚ùå Erreur migration user "${user.username}":`, error);
          stats.users.errors++;
        } else {
          console.log(`‚úÖ User "${user.username}" migr√©`);
          stats.users.migrated++;
        }
        
      } catch (error) {
        console.error(`üí• Erreur user "${user.username}":`, error);
        stats.users.errors++;
      }
    }
    
  } catch (error) {
    console.error('üí• Erreur migration users:', error);
    stats.users.errors = stats.users.existing;
  }
}

async function migrateLeads(localDb: postgres.Sql, stats: MigrationStats) {
  console.log('\nüîÑ Migration table LEADS...');
  
  try {
    // R√©cup√©rer les leads locaux
    const localLeads = await localDb`SELECT * FROM leads ORDER BY created_at DESC`;
    stats.leads.existing = localLeads.length;
    console.log(`üìä ${localLeads.length} lead(s) trouv√©(s) en local`);
    
    if (localLeads.length === 0) {
      console.log('‚ÑπÔ∏è Aucun lead √† migrer');
      return;
    }
    
    // V√©rifier leads existants Supabase
    const { data: existingLeads } = await supabaseAdmin
      .from('leads')
      .select('id');
    
    const existingLeadIds = new Set(existingLeads?.map(l => l.id) || []);
    
    // Migrer par batch de 10 pour √©viter timeout
    const BATCH_SIZE = 10;
    for (let i = 0; i < localLeads.length; i += BATCH_SIZE) {
      const batch = localLeads.slice(i, i + BATCH_SIZE);
      
      for (const lead of batch) {
        try {
          if (existingLeadIds.has(lead.id)) {
            console.log(`‚ö†Ô∏è Lead "${lead.email}" existe d√©j√† - ignor√©`);
            continue;
          }
          
          // Mapper tous les champs leads selon le sch√©ma
          const leadToMigrate = {
            id: lead.id,
            email: lead.email,
            phone: lead.phone,
            first_name: lead.first_name,
            last_name: lead.last_name,
            property_type: lead.property_type,
            address: lead.address,
            city: lead.city,
            postal_code: lead.postal_code,
            surface: lead.surface,
            rooms: lead.rooms,
            bedrooms: lead.bedrooms,
            bathrooms: lead.bathrooms,
            has_garden: lead.has_garden || false,
            has_parking: lead.has_parking || false,
            has_balcony: lead.has_balcony || false,
            construction_year: lead.construction_year,
            sale_timeline: lead.sale_timeline || '6m',
            wants_expert_contact: lead.wants_expert_contact || false,
            estimated_value: lead.estimated_value,
            project_type: lead.project_type,
            timeline: lead.timeline,
            ownership_status: lead.ownership_status,
            financing_project_type: lead.financing_project_type,
            project_amount: lead.project_amount,
            source: lead.source,
            lead_type: lead.lead_type || 'estimation_quick',
            status: lead.status || 'new',
            consent_at: lead.consent_at,
            consent_source: lead.consent_source,
            ip_address: lead.ip_address,
            guide_slug: lead.guide_slug,
            notes: lead.notes,
            created_at: lead.created_at
          };
          
          const { error } = await supabaseAdmin
            .from('leads')
            .insert(leadToMigrate);
          
          if (error) {
            console.error(`‚ùå Erreur migration lead "${lead.email}":`, error);
            stats.leads.errors++;
          } else {
            console.log(`‚úÖ Lead "${lead.email}" migr√©`);
            stats.leads.migrated++;
          }
          
        } catch (error) {
          console.error(`üí• Erreur lead "${lead.email}":`, error);
          stats.leads.errors++;
        }
      }
      
      // Pause entre batches
      if (i + BATCH_SIZE < localLeads.length) {
        console.log(`‚è∏Ô∏è Pause batch... (${i + BATCH_SIZE}/${localLeads.length})`);
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
    
  } catch (error) {
    console.error('üí• Erreur migration leads:', error);
    stats.leads.errors = stats.leads.existing;
  }
}

async function migrateEstimations(localDb: postgres.Sql, stats: MigrationStats) {
  console.log('\nüîÑ Migration table ESTIMATIONS...');
  
  try {
    const localEstimations = await localDb`SELECT * FROM estimations ORDER BY created_at DESC`;
    stats.estimations.existing = localEstimations.length;
    console.log(`üìä ${localEstimations.length} estimation(s) trouv√©e(s) en local`);
    
    if (localEstimations.length === 0) {
      console.log('‚ÑπÔ∏è Aucune estimation √† migrer');
      return;
    }
    
    const { data: existingEstimations } = await supabaseAdmin
      .from('estimations')
      .select('id');
    
    const existingIds = new Set(existingEstimations?.map(e => e.id) || []);
    
    for (const estimation of localEstimations) {
      try {
        if (existingIds.has(estimation.id)) {
          console.log(`‚ö†Ô∏è Estimation "${estimation.id}" existe d√©j√† - ignor√©e`);
          continue;
        }
        
        const estimationToMigrate = {
          id: estimation.id,
          lead_id: estimation.lead_id,
          property_type: estimation.property_type,
          address: estimation.address,
          city: estimation.city,
          surface: estimation.surface,
          rooms: estimation.rooms,
          estimated_value: estimation.estimated_value,
          price_per_m2: estimation.price_per_m2,
          confidence: estimation.confidence,
          methodology: estimation.methodology,
          comparable_properties: estimation.comparable_properties,
          created_at: estimation.created_at
        };
        
        const { error } = await supabaseAdmin
          .from('estimations')
          .insert(estimationToMigrate);
        
        if (error) {
          console.error(`‚ùå Erreur estimation "${estimation.id}":`, error);
          stats.estimations.errors++;
        } else {
          console.log(`‚úÖ Estimation migr√©`);
          stats.estimations.migrated++;
        }
        
      } catch (error) {
        console.error(`üí• Erreur estimation:`, error);
        stats.estimations.errors++;
      }
    }
    
  } catch (error) {
    console.error('üí• Erreur migration estimations:', error);
    stats.estimations.errors = stats.estimations.existing;
  }
}

async function migrateContacts(localDb: postgres.Sql, stats: MigrationStats) {
  console.log('\nüîÑ Migration table CONTACTS...');
  
  try {
    const localContacts = await localDb`SELECT * FROM contacts ORDER BY created_at DESC`;
    stats.contacts.existing = localContacts.length;
    console.log(`üìä ${localContacts.length} contact(s) trouv√©(s) en local`);
    
    if (localContacts.length === 0) {
      console.log('‚ÑπÔ∏è Aucun contact √† migrer');
      return;
    }
    
    const { data: existingContacts } = await supabaseAdmin
      .from('contacts')
      .select('id');
    
    const existingIds = new Set(existingContacts?.map(c => c.id) || []);
    
    for (const contact of localContacts) {
      try {
        if (existingIds.has(contact.id)) {
          console.log(`‚ö†Ô∏è Contact "${contact.email}" existe d√©j√† - ignor√©`);
          continue;
        }
        
        const contactToMigrate = {
          id: contact.id,
          email: contact.email,
          phone: contact.phone,
          first_name: contact.first_name,
          last_name: contact.last_name,
          subject: contact.subject,
          message: contact.message,
          source: contact.source,
          status: contact.status || 'new',
          created_at: contact.created_at
        };
        
        const { error } = await supabaseAdmin
          .from('contacts')
          .insert(contactToMigrate);
        
        if (error) {
          console.error(`‚ùå Erreur contact "${contact.email}":`, error);
          stats.contacts.errors++;
        } else {
          console.log(`‚úÖ Contact "${contact.email}" migr√©`);
          stats.contacts.migrated++;
        }
        
      } catch (error) {
        console.error(`üí• Erreur contact:`, error);
        stats.contacts.errors++;
      }
    }
    
  } catch (error) {
    console.error('üí• Erreur migration contacts:', error);
    stats.contacts.errors = stats.contacts.existing;
  }
}

async function migrateEmailTemplates(localDb: postgres.Sql, stats: MigrationStats) {
  console.log('\nüîÑ Migration table EMAIL_TEMPLATES...');
  
  try {
    const localTemplates = await localDb`SELECT * FROM email_templates ORDER BY created_at DESC`;
    stats.email_templates.existing = localTemplates.length;
    console.log(`üìä ${localTemplates.length} template(s) trouv√©(s) en local`);
    
    if (localTemplates.length === 0) {
      console.log('‚ÑπÔ∏è Aucun template √† migrer');
      return;
    }
    
    const { data: existingTemplates } = await supabaseAdmin
      .from('email_templates')
      .select('name');
    
    const existingNames = new Set(existingTemplates?.map(t => t.name) || []);
    
    for (const template of localTemplates) {
      try {
        if (existingNames.has(template.name)) {
          console.log(`‚ö†Ô∏è Template "${template.name}" existe d√©j√† - ignor√©`);
          continue;
        }
        
        const templateToMigrate = {
          id: template.id,
          name: template.name,
          subject: template.subject,
          html_content: template.html_content,
          text_content: template.text_content,
          category: template.category,
          is_active: template.is_active || true,
          variables: template.variables,
          created_at: template.created_at,
          updated_at: template.updated_at
        };
        
        const { error } = await supabaseAdmin
          .from('email_templates')
          .insert(templateToMigrate);
        
        if (error) {
          console.error(`‚ùå Erreur template "${template.name}":`, error);
          stats.email_templates.errors++;
        } else {
          console.log(`‚úÖ Template "${template.name}" migr√©`);
          stats.email_templates.migrated++;
        }
        
      } catch (error) {
        console.error(`üí• Erreur template:`, error);
        stats.email_templates.errors++;
      }
    }
    
  } catch (error) {
    console.error('üí• Erreur migration templates:', error);
    stats.email_templates.errors = stats.email_templates.existing;
  }
}

async function printMigrationSummary(stats: MigrationStats) {
  console.log('\n' + '='.repeat(60));
  console.log('üìä R√âSUM√â MIGRATION DONN√âES CRITIQUES');
  console.log('='.repeat(60));
  
  let totalExisting = 0;
  let totalMigrated = 0;
  let totalErrors = 0;
  
  const tables = [
    { name: 'Users', stats: stats.users },
    { name: 'Leads', stats: stats.leads },
    { name: 'Estimations', stats: stats.estimations },
    { name: 'Contacts', stats: stats.contacts },
    { name: 'Email Templates', stats: stats.email_templates }
  ];
  
  console.log('\nD√©tail par table :');
  tables.forEach(({ name, stats: tableStats }) => {
    const status = tableStats.errors > 0 ? '‚ö†Ô∏è' : '‚úÖ';
    console.log(`${status} ${name}: ${tableStats.migrated}/${tableStats.existing} migr√©s (${tableStats.errors} erreurs)`);
    
    totalExisting += tableStats.existing;
    totalMigrated += tableStats.migrated;
    totalErrors += tableStats.errors;
  });
  
  console.log('\n' + '-'.repeat(40));
  console.log(`üìä TOTAL: ${totalMigrated}/${totalExisting} enregistrements migr√©s`);
  console.log(`‚ùå Erreurs: ${totalErrors}`);
  console.log(`‚úÖ Succ√®s: ${totalMigrated > 0 ? 'DONN√âES SAUVEGARD√âES' : 'AUCUNE DONN√âE TROUV√âE'}`);
  
  if (totalMigrated > 0) {
    console.log('\nüéâ Migration r√©ussie ! Vos donn√©es sont maintenant dans Supabase.');
    console.log('‚ö†Ô∏è Vous pouvez maintenant supprimer la base Neon en toute s√©curit√©.');
  } else {
    console.log('\n‚ö†Ô∏è Aucune donn√©e migr√©e. V√©rifiez la connexion √† la base locale.');
  }
}

// Fonction principale
async function migrateAllDataToSupabase() {
  console.log('üöÄ MIGRATION CRITIQUE: PostgreSQL ‚Üí Supabase');
  console.log('üéØ Sauvegarde donn√©es avant suppression Neon');
  
  const stats: MigrationStats = {
    users: { existing: 0, migrated: 0, errors: 0 },
    leads: { existing: 0, migrated: 0, errors: 0 },
    estimations: { existing: 0, migrated: 0, errors: 0 },
    contacts: { existing: 0, migrated: 0, errors: 0 },
    email_templates: { existing: 0, migrated: 0, errors: 0 }
  };
  
  let localDb: postgres.Sql | null = null;
  
  try {
    // Connexion base locale
    localDb = await connectToLocalDB();
    
    // Migration des tables par ordre d'importance
    await migrateUsers(localDb, stats);
    await migrateLeads(localDb, stats);
    await migrateEstimations(localDb, stats);
    await migrateContacts(localDb, stats);
    await migrateEmailTemplates(localDb, stats);
    
    // R√©sum√© final
    await printMigrationSummary(stats);
    
  } catch (error) {
    console.error('üí• Erreur fatale migration:', error);
    process.exit(1);
  } finally {
    // Fermer connexion
    if (localDb) {
      await localDb.end();
      console.log('üîê Connexion base locale ferm√©e');
    }
  }
}

// Ex√©cution automatique
migrateAllDataToSupabase()
  .then(() => {
    console.log('\nüèÅ Script migration termin√© !');
    process.exit(0);
  })
  .catch((error) => {
    console.error('üí• Erreur fatale:', error);
    process.exit(1);
  });

export { migrateAllDataToSupabase };